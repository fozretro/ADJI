                .include "submodules/beeb/include/beeb.s65"
                .edef '\\','\'

fall_through_to: .macro dest
                .cerror *!=\dest,'fallthrough broke...'
                .endmacro

;-------------------------------------------------------------------------

default_vectors_ptr=$ffb7

os_a=$ef ; A value for osbyte/osword
os_x=$f0 ; X value for osbyte/osword
os_y=$f1 ; Y value for osbyte/osword

; seems to be relatively safe to use for brief periods with IRQs
; disabled
os_seiwk=$fa

; only safe to use with IRQs disabled!
; os_seia=$fc

; Fortunately the same on Electron OS 1.00 and Master MOS.
os_auto_repeat_countdown=$e7
os_auto_repeat_period=$255
                
; Routines that do PLA:<<restore ROM>>:PLA:PLP:RTS - as is part of the
; extended vector handling mechanism.
os_restore_rom_master=$ffa4
os_restore_rom_electron=$ff9c

line_input_pblock=$150
line_input_data=$155
                
;-------------------------------------------------------------------------
;
; See https://beebwiki.mdfs.net/OSBYTEs

; Placeholder OSBYTE used to indicate that the ROM is actually being
; entered due to KEYV.
keyv_osbyte=83

;-------------------------------------------------------------------------

brkbuf=$100

rom_name='ADJI'
rom_ver='0.01'

default_overlay_address=$150
                
; Up=0, Down=1, Left=2, Right=3, Fire=4
num_actions=5

;-------------------------------------------------------------------------
;
; ROM state logical layout. Pass offsets into this struct into
; read_state/write_state.
; 
State: .struct
jflags: .block
                
; Index of joystick interface to use.
jindex_mask=%00000011
                
; If set, treat joystick inputs as keyboard inputs.
jkeys_mask=%00000100
                
; If set, treat joystick inputs as analogue inputs.
jon_mask=%01000000
                .fill 1
                .endblock
; Keys are stored as internal key numbers. See AUG p 142.
action_keys: .fill num_actions
               .endstruct
                .cerror State.jflags!=0,'State jflags must be at offset 0'

;-------------------------------------------------------------------------
;
; ROM state on Master 128 is stored in a page in HAZEL. Layout just as
; per the struct.
;

; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
; master_spare=$0261

;-------------------------------------------------------------------------
;
; ROM state on Electron.
;
; The various bytes are stored in page 2, in locations that Electron
; OS 1.00 doesn't use.
;
; $0290 is used by the Slogger Electron Expansion ROM as follows:
;
; bit 6 = ADC/digital joystick select
; bits 0/1 = digital joystick index
;
; The ADJI ROM jflags are compatible.
;
; Also unused on Electron:
;
; $0261 - "speech suppression status" - unused in practice?
; $027e - unused
; $2082 - used by MRB??
; $028a - used by MRB??
; $028b - used by MRB??
; 
elk_jflags=$0290                ;unused by Electron OS
elk_up=$02a8                    ;ROM flags for keyboard
elk_down=$02a9                  ;ROM flags for keyboard
elk_left=$02aa                  ;ROM flags for lower-priority BASIC
elk_right=$02f5                 ;unused by Electron OS
elk_fire=$02f6                  ;unused by Electron OS

;-------------------------------------------------------------------------

machine_type_other=0
machine_type_electron=1
machine_type_master=2

jup_mask=1
jdown_mask=2
jleft_mask=4
jright_mask=8
jfire_mask=16
jall_mask=jfire_mask|jright_mask|jleft_mask|jdown_mask|jup_mask
                
;-------------------------------------------------------------------------

struct_section: .macro
                .struct
                .dsection \1
                .ends
                .endmacro

*=$a8
                ; Leaf routines that only use transient zp workspace
                .union
                .struct_section verbose_get_key_workspace
                .struct_section print_joystick_action_name_workspace
                .endunion

                ; Leaf routines that return a result in zero page
                .union
                .struct_section strtoi_workspace
                .endunion

                ; * commands
                .union
                .struct_section cmd_jtest_workspace
                .struct_section cmd_jon_workspace
                .struct_section cmd_jkeys_workspace
                .endunion
                
                .cerror *>$b0,'zp overflow'

;-------------------------------------------------------------------------

*=$b0
                ; Leaf routines that only use transient zp workspace
                ; and make no FS calls (or can survive their workspace
                ; being zapped if one is made).
                ;
                ; This region isn't a union, as space here is a bit
                ; less tight than in $a8...$af.
                .struct_section print_following_string_workspace
                .struct_section find_command_workspace
                .struct_section reset_default_vectors_workspace
                .struct_section install_xvector_workspace
                .struct_section read_or_write_state_workspace
                .cerror *>$c0,'FS scratch zp overflow'

;-------------------------------------------------------------------------

*=$8000
                .dsection code
                .if debug
                ; The debug ROM is for loading into sideways RAM or
                ; similar, and can occupy the full 16 KB.
                .cerror *>$c000,'code overflow'
                .else
                ; The real ADJI ROM is 4 KB.
                .cerror *>$9000,'code overflow'
                .endif
                
;-------------------------------------------------------------------------

                .section code
rom_header:
                .byte 0,0,0     ;language entry (none)
                jmp svc         ;service entry
                .byte $82       ;ROM type: service entry, 6502 code
                .byte <rom_copyright
                .byte 0
rom_title:
                .text rom_name
                .byte 0
rom_version:
                .text rom_ver
rom_copyright:
                .byte 0
                .text '(C) 2023 Retro Hardware'
rom_copyright_end:
                .byte 0

;-------------------------------------------------------------------------

command_table_entry: .function name,routine,help_offset
_start:
                .cerror (routine&$8000)==0,'routine address bit 15 must be set'
                .text name
                .byte >(routine-1)
                .byte <(routine-1)
                .byte help_offset
                .endfunction _start-command_table
                
command_table: .block
subjects_offset=*-command_table
                .command_table_entry "ADJI",help_adji,help_table.none_offset
                .byte 0
cmds_offset=*-command_table
                .command_table_entry "JON",cmd_jon,help_table.jon_offset
                .command_table_entry "JOFF",cmd_joff,help_table.none_offset
                .command_table_entry "JKEYS",cmd_jkeys,help_table.jkeys_offset
                .command_table_entry "JSTATE",cmd_jstate,help_table.none_offset
                .command_table_entry "JTEST",cmd_jtest,help_table.jtest_offset
                .command_table_entry "KTEST",cmd_ktest,help_table.none_offset
                .byte 0
                .endblock

help_table: .block
jtest_offset=*-help_table
                .text ' <no>'
none_offset=*-help_table
                .text 0
jon_offset=*-help_table
                .text ' <no> X|<addr>',0
jkeys_offset=*-help_table
                .text ' <no> <up> <down> <left> <right> <fire> X|<addr>',0
                .endblock

;-------------------------------------------------------------------------

error_table_entry: .function err,text
_start:
                .byte err
                .text text
                .byte 0
                .endfunction _start-errors_table

errors_table: .block
bad_hex_offset: .error_table_entry $fe,'Bad hex'
incompatible_hw_offset: .error_table_entry $ff,'Electron/Master 128 only'
key_missing_offset: .error_table_entry $dc,'Key missing'
bad_jno_offset: .error_table_entry $dc,'Bad joystick'
no_free_hazel: .error_table_entry $ff,'No free FS RAM'
bad_mode: .error_table_entry $ff,'Bad mode'
todo_offset: .error_table_entry $ff,'TODO'
electron_todo_offset: .error_table_entry $ff,'Electron = TODO'
                .endblock
                
;-------------------------------------------------------------------------

key_table_entry: .macro ascii,name,key_number
                .cerror (\key_number&$80)!=0,'oops'
                .byte \ascii
                .text \name
                .byte \key_number|$80
                .endmacro

keys_table:
                ; BBC/Electron keys
                .key_table_entry 'A','A',key_a
                .key_table_entry 'B','B',key_b
                .key_table_entry 'C','C',key_c
                .key_table_entry 'D','D',key_d
                .key_table_entry 'E','E',key_e
                .key_table_entry 'F','F',key_f
                .key_table_entry 'G','G',key_g
                .key_table_entry 'H','H',key_h
                .key_table_entry 'I','I',key_i
                .key_table_entry 'J','J',key_j
                .key_table_entry 'K','K',key_k
                .key_table_entry 'L','L',key_l
                .key_table_entry 'M','M',key_m
                .key_table_entry 'N','N',key_n
                .key_table_entry 'O','O',key_o
                .key_table_entry 'P','P',key_p
                .key_table_entry 'Q','Q',key_q
                .key_table_entry 'R','R',key_r
                .key_table_entry 'S','S',key_s
                .key_table_entry 'T','T',key_t
                .key_table_entry 'U','U',key_u
                .key_table_entry 'V','V',key_v
                .key_table_entry 'W','W',key_w
                .key_table_entry 'X','X',key_x
                .key_table_entry 'Y','Y',key_y
                .key_table_entry 'Z','Z',key_z
                .key_table_entry '0','0',key_0
                .key_table_entry '1','1',key_1
                .key_table_entry '2','2',key_2
                .key_table_entry '3','3',key_3
                .key_table_entry '4','4',key_4
                .key_table_entry '5','5',key_5
                .key_table_entry '6','6',key_6
                .key_table_entry '7','7',key_7
                .key_table_entry '8','8',key_8
                .key_table_entry '9','9',key_9
                .key_table_entry '-','-',key_minus
                .key_table_entry ';',';',key_semicolon
                .key_table_entry ':',':',key_colon
                .key_table_entry ',',',',key_comma
                .key_table_entry '.','.',key_stop
                .key_table_entry '/','/',key_slash
                .key_table_entry ' ',"SPACE",key_space
                .key_table_entry $1B,"ESCAPE",key_escape
                .key_table_entry $7F,"DELETE",key_delete
                .key_table_entry $D,"RETURN",key_return
                .key_table_entry $8B,"CURSOR UP",key_up
                .key_table_entry $8A,"CURSOR DOWN",key_down
                .key_table_entry $88,"CURSOR LEFT",key_left
                .key_table_entry $89,"CURSOR RIGHT",key_right
                .key_table_entry $87,"COPY",key_copy
                .key_table_entry 1,"SHIFT",key_shift
                .key_table_entry 2,"CTRL",key_ctrl
                .key_table_entry 3,"CAPS LOCK",key_caps_lock
                
                ; BBC keys
                .key_table_entry '@','@',key_at
                .key_table_entry '[','[',key_left_square_bracket
                .key_table_entry '\\','\\',key_backslash
                .key_table_entry ']',']',key_right_square_bracket
                .key_table_entry '^','^',key_caret
                .key_table_entry '_','_',key_underline
                .key_table_entry 9,"TAB",key_tab
                .key_table_entry 4,"SHIFT LOCK",key_shift_lock
                .key_table_entry $80,"f0",key_f0
                .key_table_entry $81,"f1",key_f1
                .key_table_entry $82,"f2",key_f2
                .key_table_entry $83,"f3",key_f3
                .key_table_entry $84,"f4",key_f4
                .key_table_entry $85,"f5",key_f5
                .key_table_entry $86,"f6",key_f6
                .key_table_entry $87,"f7",key_f7
                .key_table_entry $88,"f8",key_f8
                .key_table_entry $89,"f9",key_f9
                
                ; Master 128 keys
                .key_table_entry '0','NUM 0',$6a
                .key_table_entry '1','NUM 1',$6b
                .key_table_entry '2','NUM 2',$7c
                .key_table_entry '3','NUM 3',$6c
                .key_table_entry '4','NUM 4',$7a
                .key_table_entry '5','NUM 5',$7b
                .key_table_entry '6','NUM 6',$1a
                .key_table_entry '7','NUM 7',$1b
                .key_table_entry '8','NUM 8',$2a
                .key_table_entry '9','NUM 9',$2b
                .key_table_entry '+','NUM +',key_numpad_plus
                .key_table_entry '-','NUM -',key_numpad_minus
                .key_table_entry '/','NUM /',key_numpad_divide
                .key_table_entry '#','NUM #',key_numpad_hash
                .key_table_entry '*','NUM *',key_numpad_multiply
                .key_table_entry ',','NUM ,',key_numpad_comma
                .key_table_entry $d,'NUM RETURN',key_numpad_return
                .key_table_entry $7f,'NUM DELETE',key_numpad_delete
                .key_table_entry '.','NUM .',key_numpad_stop
                .text 0
                
;-------------------------------------------------------------------------

svc: .proc
                pha
                cmp #$15
                beq unclaimed   ;fast path for 100 Hz polling
                                ;interrupt
                cmp #4
                beq star
                cmp #9
                beq help
                ; https://beebwiki.mdfs.net/Using_high_workspace
                cmp #$22
                beq claim_hazel
                cmp #$24
                beq count_hazel
unclaimed:
                pla
done:
                ldx $f4
                rts

claimed:
                pla
                lda #0
                beq done    ;i.e., JMP

count_hazel:
                dey             ;1 page required
                jmp unclaimed

claim_hazel:
                tya
                cmp #$dc        ;run out of HAZEL space?
                bcc +           ;taken if not run out
                lda #0          ;indicate workspace unavailable
+
                sta $df0,x
                iny             ;claim 1 page
                jmp unclaimed
                
help:
                tya
                pha
                jsr find_string_tail
                bcs no_help_subject ;taken if command line empty
                ldx #command_table.subjects_offset
                pla
                pha
                tay
                jsr find_command ;try to find subject
                bcc found_subject
                ; Command line not for us - do nothing and pass on.
pla_tay_unclaimed:
                pla
                tay
                jmp unclaimed

no_help_subject:
                jsr print_help_banner
                ldx #command_table.subjects_offset
                jsr print_help
                jmp pla_tay_unclaimed

found_subject:
                jsr print_help_banner
                sec
                jsr call_command_table_routine
                jmp pla_tay_unclaimed

star:
                tya
                pha
                ldx #command_table.cmds_offset
                jsr find_command
                bcc found_command
                jmp pla_tay_unclaimed
                
found_command:
                clc
                jsr call_command_table_routine
                pla
                tay
                jmp claimed

print_help_banner .proc
                jsr osnewl
                ldy #<rom_title
-
                lda rom_header,y
                bne +
                lda #' '
+
                jsr oswrch
                iny
                cpy #rom_copyright-rom_header
                bne -
                rts
                
                .endproc
                
                .endproc

;-------------------------------------------------------------------------

help_adji: .proc
                ldx #command_table.cmds_offset
                jmp print_help
                .endproc

;-------------------------------------------------------------------------
;
; Print help for part of the commands table.
;
; Entry: X = offset of first command
;
print_help: .proc
                jsr osnewl
cmds_loop:
                lda command_table,x
                beq done
                lda #' '
                jsr oswrch
                jsr oswrch
cmd_name_loop:
                lda command_table,x
                bmi name_done
                jsr oswrch
                inx
                bne cmd_name_loop
name_done:
                inx
                inx
                ldy command_table,x
                inx
help_loop:
                lda help_table,y
                beq next
                jsr oswrch
                iny
                bne help_loop
next:
                jsr osnewl
                jmp cmds_loop
done:
                rts
                .endproc

;-------------------------------------------------------------------------

cmd_joff:
                jsr reset_default_vectors
                rts

;-------------------------------------------------------------------------
                
cmd_jon: .proc
                .section cmd_jon_workspace
joystick_index: .fill 1
yval: .fill 1
                .endsection

                jsr must_be_valid_hw

                jsr reset_default_vectors

                jsr parse_jno
                sta joystick_index

                sty yval
                
                ldy #State.jflags
                jsr read_state
                and #~(State.jflags.jindex_mask|State.jflags.jkeys_mask|State.jflags.jon_mask)
                ora #State.jflags.jon_mask
                ora joystick_index
                jsr write_state
                
                ldy yval
                .fall_through_to handle_install_mode
                .endproc

handle_install_mode: .proc
                jsr find_string_tail
                bcc +

                ldx #errors_table.bad_mode
                jmp do_error

+
                and #$df
                cmp #'X'
                beq install_xvector
                jsr strtoi
                .fall_through_to install_overlay
                .endproc

;-------------------------------------------------------------------------
;
; Install overlay routines.
;
; Entry: (strtoi_value) = dest pointer
;        state jflags
; 
install_overlay: .proc
                jsr must_be_valid_hw
                bvs +
                ldx #errors_table.electron_todo_offset
                jmp do_error
+
                ldy #size(overlay_master)-1
loop:
                lda overlay_master,y
                sta (strtoi_value),y
                dey
                bpl loop

                ; Fix up ROMSEL value.
                ldy #overlay_master.rom_offset
                lda $f4
                sta (strtoi_value),y

                ; Fix up workspace page.
                tay
                lda $df0,y
                ldy #overlay_master.workspace_page
                sta (strtoi_value),y

                ; Point BYTEV to the right place.
                lda #overlay_master.osbyte_entry_offset
                ldx #<bytev
                jsr set_overlay_vector

                ; Maybe point KEYV to the right place.
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask
                beq keyv_done
                lda #overlay_master.keyv_entry_offset
                ldx #<keyv
                jsr set_overlay_vector
keyv_done:

                rts

set_overlay_vector:
                php
                sei
                clc
                adc strtoi_value+0
                sta $200,x
                lda strtoi_value+1
                adc #0
                sta $201,x
                plp
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Install xvector routines.
;
; Entry: state jflags
install_xvector: .proc
                .section install_xvector_workspace
xvectors: .fill 2
                .endsection
                lda #$a8        ;read extended vector table address
                ldx #$00
                ldy #$ff
                jsr osbyte
                stx xvectors+0
                sty xvectors+1

                jsr must_be_valid_hw
                bvs +           ;taken if Master 128
                ldx #errors_table.electron_todo_offset
                jmp do_error
+

                php
                sei

                ; BYTEV
                lda #$ff
                sta bytev+1
                ldy #(<bytev)/2*3
                sty bytev+0
                lda #<handle_osbyte_xvector_master
                sta (xvectors),y
                iny
                lda #>handle_osbyte_xvector_master
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y

                ; KEYV
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask
                beq keyv_done

                lda #$ff
                sta keyv+1
                ldy #(<keyv)/2*3
                sty keyv+0
                lda #<handle_keyv_xvector_master
                sta (xvectors),y
                iny
                lda #>handle_keyv_xvector_master
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y
keyv_done:
                
                plp
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Handle OSBYTE on Master 128 when called via extended vector.
;
; Entry: A/X/Y = as per OSBYTE
; 
handle_osbyte_xvector_master: .proc
                .cpu '65c02'
                php
                sei
                sta os_a
                stx os_x
                sty os_y
                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0
                jmp handle_osbyte_master
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine for Master 128.
;
; Entry: A/X/Y/P as per OSBYTE or KEYV (according to entry point)
;
overlay_master: .block
                .cpu '65c02'
keyv_entry_offset=*-overlay_master
                lda #keyv_osbyte
osbyte_entry_offset=*-overlay_master
                php
                sei
                pha             ;save input A
rom_offset=*+1-overlay_master
                lda #$ff
                sta $fe30
workspace_page=*+1-overlay_master
                lda #$ff
                jmp handle_osbyte_overlay_master
                .endblock

                ; Unlikely
                .cerror size(overlay_master)>128,'overlay too large'

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine suffix for Master 128
;
; Entry: A = workspace address MSB
;        X/Y = as per OSBYTE
;        Stack = [A, P, OSBYTE ret]
; 
handle_osbyte_overlay_master:
                ; Store workspace address in SEIWK.
                sta os_seiwk+1
                stz os_seiwk+0

                ; Store input registers in zero page.
                pla             ;restore input A
                sta os_a
                stx os_x
                sty os_y

                plx             ;restore input P

                ; Save ROMSEL
                lda $f4
                pha
                
                ; Make ROMSEL and $f4 consistent
                lda $fe30
                sta $f4

                ; Insert overlay exit routine addres
                lda #>handle_overlay_exit_master-1
                pha
                lda #<handle_overlay_exit_master-1
                pha

                phx             ;Save input P

                jmp handle_osbyte_master

; Entry: A/X/Y/P as per OSBYTE return
; Stack: [old ROMSEL, return address]
handle_overlay_exit_master:
                .cpu '65c02'
                pha
                php
                phx
                tsx
                ; S = X P A ROMSEL RetL RetH
                lda $104,x      ;ROMSEL
                pha             ;S = ROMSEL | X P A ROMSEL RetL RetH
                lda $102,x      ;P
                sta $104,x      ;S = ROMSEL | X P A P RetL RetH
                pla             ;S = | X P A P RetL RetH
                sta $102,x      ;S = | X ROMSEL A P RetL RetH
                plx             ;S = ROMSEL A P RetL RetH
                jmp os_restore_rom_master
                .cpu 'default'

;-------------------------------------------------------------------------
;
; KEYV xvector handler for Master 128
;
; Entry: just as per KEYV
handle_keyv_xvector_master: .proc
                .cpu '65c02'
                php
                sei
                sta os_a
                stx os_x
                sty os_y
                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0
                jmp keyv_master
                .cpu 'default'                
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV handler for Master 128
; 
; Entry: ?os_a, ?os_x, ?os_y = OSBYTE/KEYV entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]

handle_osbyte_master:
                lda os_a

                cmp #keyv_osbyte
                beq keyv_master

                cmp #$80
                beq osbyte_80_master

                cmp #$81
                beq osbyte_81_master
osbyte_unhandled:
                ldx os_x
                ldy os_y
                plp
                jmp jmp_default_osbyte

;-------------------------------------------------------------------------
;
; OSBYTE $81 handler for Master 128.
;
; Entry: A = $81, ?os_a = $81
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
;
osbyte_81_master: .proc
                .cpu '65c02'
                ldx os_x
                ldy os_y
                bpl timeout
                lda os_a
                jmp jmp_default_osbyte.with_p_already_pushed

timeout:
                ; 
                ; Form negated timeout in Y/X.
                tya
                eor #$ff
                tay
                txa
                eor #$ff
                tax

loop:
                ; Save timeout.
                pla             ;old IRQ state [RL RH]
                pha             ;save old IRQ state [P RL RH]
                phy             ;[Y P RL RH]
                phx             ;[X Y P RL RH]
                pha             ;save old IRQ state again [P X Y P RL RH]

                ; Read joystick.
                lda acccon
                pha             ;[ACCCON P X Y P RL RH]
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda (os_seiwk)
                and #3
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                and #jall_mask
                beq try_osbyte  ;taken if obviously nothing pressed

                ; Find state offset for action.
                ;
                ; TODO: there'll probably be room to have this in a
                ; table.
                ldy #State.action_keys-1
find_index_loop:
                iny
                lsr a
                bcc find_index_loop

                lda (os_seiwk),y
                bpl jkey_pressed
                
try_osbyte:
                pla             ;[P X Y P RL RH]
                sta acccon
                
                lda os_seiwk+1
                plp             ;Restore IRQ state [X Y P RL RH]
                pha             ;Save workspace ptr MSB [WH X Y P RL RH]

                ldy #0
                ldx #1
                lda #$81
                jsr jmp_default_osbyte
                cpy #$ff
                bne kkey_pressed

                lda #1
                sta os_auto_repeat_countdown

                ; Restore state.
                pla             ;Restore workspcae ptr MSB [X Y P RL RH]
                sei
                sta os_seiwk+1
                stz os_seiwk+0

next:
                ; Increment timeout, and keep going until 0.
                plx             ;[Y P RL RH]
                ply             ;[P RL RH]
                
                inx
                bne loop
                iny
                bne loop

                ; X=0, Y=0. Timed out. Return with C=1 and Y=$ff.
                plp             ;[RL RH]
                dey
                sec
                rts
                .cpu 'default'

kkey_pressed:
                pla             ;discard workspace ptr MSB [X Y P RL RH]
                pla             ;discard counter LSB [Y P RL RH]
                pla             ;discard counter MSB [P RL RH]
                plp             ;restore IRQ state [RL RH]
                dey             ;Y=0
                lda #$81        ;A is preserved
                clc
                rts

jkey_pressed:
                ldx os_auto_repeat_countdown
                beq reset_auto_repeat_countdown
                dec os_auto_repeat_countdown
                bne try_osbyte
reset_auto_repeat_countdown:
                ldx os_auto_repeat_period
                stx os_auto_repeat_countdown
                
                pha             ;save internal key number [K ACCCON P X Y P RL RH]
                lda #$ac        ;Keyboard translation table address
                                ;AUG p 183
                ldx #$00
                ldy #$ff
                jsr osbyte
                sei
                stx os_seiwk+0  ;keyboard translation table LSB
                sty os_seiwk+1  ;keyboard translation table MSB
                pla             ;restore internal key number [ACCCON P X Y P RL RH]
                tay             ;Y=internal key number
                lda (os_seiwk),y
                bne +           ;taken if not TAB
                lda #9          ;TODO: proper TAB support
+
                tax             ;X = ASCII value of key pressed
                pla             ;get old ACCCON value [P X Y P RL RH]
                sta acccon
                pla             ;discard old IRQ state copy [X Y P RL RH]
                pla             ;discard counter LSB [Y P RL RH]
                pla             ;discard counter MSB [P RL RH]
                plp             ;restore old IRQ state [RL RH]
                lda os_a
                clc
                rts
                
                .endproc

;        
;-------------------------------------------------------------------------
;
; OSBYTE $80 handler for Master 128.
;
; Entry: A = $80, ?os_a = $80
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
; 
osbyte_80_master: .proc
                ; Bail if not ADVAL.
                ldx os_x
                cpx #5
                bcs osbyte_unhandled
                
                .cpu '65c02'
                ; Save old ACCCON. Page in HAZEL. Direct FRED to
                ; cartridge.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Fetch joystick index.
                ldy #State.jflags
                lda (os_seiwk),y
                bit #State.jflags.jon_mask
                beq default
                and #3

                ; ?os_a = joystick value
                tay
                lda joystick_fred_offsets,y
                tay
                lda $fc00,y
                sta os_a

                ; Restore old ACCCON.
                pla
                sta acccon

                ; OK to possibly re-enable IRQs now.
                plp
                
                jmp osbyte_80_generic
                .cpu 'default'

default:
                pla
                sta acccon
                lda os_a
                jmp osbyte_unhandled
                .endproc
;-------------------------------------------------------------------------
;
; KEYV handler for Master 128.
;
; Entry: A = keyv_osbyte
;        ?os_x, ?os_y = KEYV arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
keyv_master: .proc
                .cpu '65c02'
                pla             ;restore P
                pha             ;re-save P
                and #%01000001  ;separate C+V
                cmp #%00000001  ;check for C=1 V=0
                bne jmp_default_keyv.with_p_already_pushed

                ; Check for keyboard scan mode.
                lda os_x
                bpl scan_multiple_keys ;taken if scanning for multiple
                                       ;keys

scan_single_key: .block
                ; Convert to internal key number.
                and #$7f
                sta os_x
                
                ; Set up ACCCON.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Read joystick flags into X
                lda (os_seiwk)
                bit #State.jflags.jkeys_mask
                beq default
                and #3
                tax
                ldy joystick_fred_offsets,x
                ldx $fc00,y

                ldy #State.action_keys+num_actions-1
loop:
                lda os_x        ;key of interest
                cmp (os_seiwk),y
                bne next        ;taken if not this jkey
                txa             ;get joystick flags
                and joystick_action_masks-State.action_keys,y
                bne pressed     ;taken if this jkey pressed
next:
                dey
                bne loop

default:
                ; Restore ACCCON.
                pla
                sta acccon

                ; Key was not one of the joystick keys, so forward the
                ; call on to KEYV.
                lda os_x
                ora #$80        ;reinstate bit 7, masked out above
                tax
                lda os_a
                ldy os_y
                jmp jmp_default_keyv.with_p_already_pushed

pressed:
                ; Restore ACCCON.
                pla
                sta acccon

                ; Report key pressed.
                lda os_a
                ldx #$ff
                ldy os_y
                plp
                rts
                .endblock
                
scan_multiple_keys: .block
                lda os_x
                pha
                lda os_seiwk+1
                pha
                sec
                clv
                ldx os_x
                jsr jmp_default_keyv

                ; Save KEYV result.
                stx os_y

                ; Restore old state: IRQs disabled, os_seiwk set up,
                ; os_x as per entry.
                sei
                stz os_seiwk+0
                pla
                sta os_seiwk+1
                pla
                sta os_x

                ; Set up ACCCON.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Read joystick flags.
                lda (os_seiwk)
                and #3
                tax
                ldy joystick_fred_offsets,x
                ldx $fc00,y
                ldy #State.action_keys+num_actions-1
loop:
                txa             ;A=joystick flags
                and joystick_action_masks-State.action_keys,y
                beq next        ;taken if not pressed

                lda (os_seiwk),y ;get key for this action
                cmp os_x         ;within scan range?
                bcc next         ;taken if not
                beq next         ;taken if not
                cmp os_y         ;existing result covers it?
                bcs next         ;taken if so
                sta os_y

next:
                dey
                bne loop

                ; Restore old ACCCON.
                pla
                sta acccon

                ldx os_y
                lda os_a
                plp
                rts
                .endblock
                .endproc
                
;-------------------------------------------------------------------------
;
; Handle OSBYTE $80, X<=4
;
; Entry: ?os_a = value read from joystick
;        X = X value for OSBYTE $80 call
;        
osbyte_80_generic: .proc
                cpx #0
                beq test_fire

                lda os_a
                and max_value_masks-1,x
                bne max_value

                lda os_a
                and min_value_masks-1,x
                bne min_value

zero:
                ldx #$00
                ldy #$80
                rts

max_value:
                ldx #$ff
                ldy #$ff
                rts

min_value:
                ldx #$00
                ldy #$00
                rts

test_fire:
                ldy #4          ;fake last ADC conversion channel
                
                lda os_a
                and #jfire_mask
                bne fire_yes
fire_no:
                ldx #0
                rts

fire_yes:
                ldx #1
                rts

min_value_masks: .byte jright_mask,jup_mask,0,0
max_value_masks: .byte jleft_mask,jdown_mask,0,0
                .endproc

;-------------------------------------------------------------------------
; 
; jmp_default_osbyte
;
jmp_default_osbyte: .proc
                php
                sei
with_p_already_pushed:
                pha
                sty os_y
                ldy #<bytev
                bne jmp_default_vector_routine
                .endproc
                
jmp_default_keyv: .proc
                php
                sei
with_p_already_pushed:
                pha
                sty os_y
                ldy #<keyv
                .cerror *!=jmp_default_vector_routine,'fallthrough broke'
                .endproc
jmp_default_vector_routine: .proc
                lda default_vectors_ptr+0
                sta os_a
                lda default_vectors_ptr+1
                sta os_x
                lda (os_a),y    ;get LSB of routine
                pha
                iny
                lda (os_a),y    ;get MSB of routine
                sta os_x        ;store MSB of routine
                pla             ;restore LSB of routine
                sta os_a        ;store LSB of routine
                ldy os_y        ;restore input Y
                pla             ;restore input A
                plp             ;restore input P
                jmp (os_a)      ;call routine
                .endproc
                
;-------------------------------------------------------------------------

cmd_jkeys: .proc
                .section cmd_jkeys_workspace
index: .fill 1
yval: .fill 1
state_index: .fill 1
                .endsection

                jsr parse_jno
                sta index
                sty yval

                ldy #State.jflags
                jsr read_state
                and #~(State.jflags.jindex_mask|State.jflags.jkeys_mask|State.jflags.jon_mask)
                ora #State.jflags.jkeys_mask
                ora index
                jsr write_state

                lda #State.action_keys
                sta index

loop:
                ldy yval
                jsr strtoi
                sty yval

                ; convert to internal key number
                eor #$ff
                and #$7f

                ldy index
                jsr write_state

                iny
                sty index
                cpy #State.action_keys+num_actions
                bne loop

                ldy yval
                jmp handle_install_mode
                .endproc
                
;-------------------------------------------------------------------------

cmd_jtest: .proc
                .section cmd_jtest_workspace
joystick_index: .fill 1
action_index: .fill 1
                .endsection
                
                jsr parse_jno
                sta joystick_index
                
                jsr print_following_string
                .text 22,135
                .text 31,8,5
                .text "J O Y S T I C K   T E S T"
                .byte 0

                jsr coff

loop:
                bit $ff
                bmi done        ;taken if Escape pressed

                lda #4
                sta action_index
check_actions:
                jsr print_following_string
                .byte 31,17,0
                
                lda action_index
                clc
                adc #10         
                jsr oswrch      ;PRINT TAB(17,Y)

                ldx joystick_index
                jsr read_joystick
                
                ldx action_index
                and joystick_actions.masks,x
                bne +
                ldx #$ff        ;no action
+
                jsr print_joystick_action_name

                dec action_index
                bpl check_actions
                jmp loop

done:
                jsr con
                lda #$7e
                jsr osbyte
                lda #12
                jmp oswrch
                
                .endproc

;-------------------------------------------------------------------------
;
; Print joystick action name, padded on the right with spaces.
;
; Entry: X = joystick action index, or $FF for no blanks
print_joystick_action_name: .proc
                .section print_joystick_action_name_workspace
pja_index: .fill 1
                .endsection

                inx
                stx pja_index
                txa
                asl a           ;*2, C=0
                asl a           ;*4, C=0
                adc pja_index   ;*5
                tay
print:
                ldx #4
-
                lda joystick_actions.names,y
                jsr oswrch
                iny
                dex
                bpl -
                rts
                .endproc

;-------------------------------------------------------------------------

joystick_actions: .block
masks:
                .byte 1,2,4,8,16
names:
                ;      01234
                .text "     "
                .text "UP   "
                .text "DOWN "
                .text "LEFT "
                .text "RIGHT"
                .text "FIRE "
                .endblock

;-------------------------------------------------------------------------

cmd_ktest: .proc
                jsr print_following_string
                .text 'Press keys...',10,13,0

ktest_loop:
                jsr verbose_get_key

                jsr print_following_string
                .text ' | ',0

                bit $ff
                bpl ktest_loop

                lda #15
                ldx #0
                jsr osbyte
                rts
                
                .endproc

;-------------------------------------------------------------------------

cmd_jstate: .proc
                ldx #0
loop:
                jsr print_following_string
                .text '+&',0

                txa
                jsr print_hex_byte

                jsr print_following_string
                .text ': &',0

                txa
                tay
                jsr read_state
                jsr print_hex_byte

                jsr osnewl

                inx
                cpx #size(State)
                bne loop
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Switch cursor on (con) or off (coff)
; 
con:
                ldx #con_vdu-cset_vdu
                jmp cset
coff:
                ldx #coff_vdu-cset_vdu
cset:
                ldy #10
cset_loop:
                lda cset_vdu,x
                jsr oswrch
                inx
                dey
                bne cset_loop
                rts
                
cset_vdu:
con_vdu:
                .byte 23,1,1
coff_vdu:
                .byte 23,1,0
                ; doens't matter what comes next...
                
;-------------------------------------------------------------------------
;
; Parse <no> argument from command line. Does a BRK for invalid
; joystick numbers.
;
; Entry: ($f2),y = command line pointer
; Exit: ($f2),y = updated command line pointer
;       A = joystick index, 0-3
parse_jno: .proc
                jsr strtoi
                sec
                sbc #1
                cmp #4
                bcc +
                ldx #errors_table.bad_jno_offset
                jmp do_error
+
                rts
                .endproc
;
;-------------------------------------------------------------------------
;
; Wait for a keypress. Print the pressed key's name.
;
; Exit: X = INKEY value of key pressed
verbose_get_key: .proc
                .section verbose_get_key_workspace
vgk_ptr: .fill 2
                .endsection
                
                lda #<keys_table
                sta vgk_ptr+0
                lda #>keys_table
                sta vgk_ptr+1

keys_loop:
                ldy #0
                lda (vgk_ptr),y ;check for terminator
                beq verbose_get_key
                iny             ;skip ASCII
find_name_end_loop:
                lda (vgk_ptr),y
                beq verbose_get_key
                bmi found_name_end
                iny
                bne find_name_end_loop
found_name_end:
                tya
                pha             ;save offset of key number

                jsr poll_key

                pla             ;restore offset of key number
                bcs pressed     ;taken if key was pressed
                
                sec             ;+1 to get to next key's struct
                adc vgk_ptr+0
                sta vgk_ptr+0
                bcc keys_loop
                inc vgk_ptr+1
+
                jmp keys_loop

pressed:
wait_for_release_loop:
                pha             ;save offset
                jsr poll_key
                tax             ;X = INKEY value
                pla             ;restore offset
                bcs wait_for_release_loop

                ldy #1
print_name_loop:
                lda (vgk_ptr),y
                bmi printed_name
                jsr oswrch
                iny
                bne print_name_loop
printed_name:
                rts

; poll for key
;
; Entry: (vgk_ptr) = entry in table
;        A = offset from vgk_ptr of (INKEY value)^0x7f
; Exit: A = INKEY value
;       C=1 if key down, C=0 if key up
poll_key:
                tay
                lda (vgk_ptr),y
                eor #$7f
                pha
                tax
                ldy #$ff
                lda #$81
                jsr osbyte
                cpx #$ff
                pla
                rts
                
                .endproc
                
;-------------------------------------------------------------------------
;
; Cause an error.
;
; Entry: X = offset of error data in errors_table
do_error: .proc
                ldy #0
                sty brkbuf
                dex
                dey

L935E:
                inx
                iny
                lda errors_table,x
                sta brkbuf+1,y
                bne L935E
                jmp brkbuf
                .endproc
                
;-------------------------------------------------------------------------
;
; Find string tail.
; Entry: ($f2),y = string pointer
; Exit: C=0 - something on command line, ($f2),y points to it, A=first char
;       C=1 - nothing on command line, ($f2),y points to end, A=13
; Preserves: X
retry_find_string_tail:
                iny
find_string_tail:
                lda ($f2),y     ; read next value from command line
                cmp #13
                beq _done       ; taken with C=1 if eol
                cmp #' '
                beq retry_find_string_tail ; taken with C=1 if space -
                                          ; move to next byte and try
                                          ; again
                clc
_done:
                rts

;-------------------------------------------------------------------------
;
; Call found command's command table routine.
; Entry: X = offset into command table of MSB of command routine
call_command_table_routine: .proc
                lda command_table,x
                pha
                lda command_table+1,x
                pha
                rts
                .endproc

;-------------------------------------------------------------------------
; 
; Try to find command in commands table
; Entry: ($f2),y = pointer to string
;        X = offset into command_table
; Exit: C=0 if command found
;       X = offset of routine address
;           (ready for call_command_table_routine)
find_command: .block
                .section find_command_workspace
fc_table_offset: .fill 1
fc_string_offset: .fill 1
                .endsection
                
                stx fc_table_offset
                clc
                jsr find_string_tail; Check if command line tail is empty.
                                   ; Entry: ($f2),y = command line tail
                                   ; Exit:  C=0 - something on command line
                                   ;        C=1 - nothing on command line
                sty fc_string_offset

L9245:
                ldy fc_string_offset
                dex
                dey

L9249:
                inx
                iny
                lda command_table,x
                sec
                beq done        ; taken if end of table reached
                bmi L9269
                eor ($F2),y
                and #$5F
                beq L9249
                lda ($F2),y
                cmp #'.'
                beq L9271

L925F:
                inx
                lda command_table,x
                bpl L925F       ; taken if end of command name reached

L9265:
                inx
                inx
                inx
                bne L9245

L9269:
                lda ($F2),y
                jsr isalpha     ; Check if char is alphabetic
                                ; Entry: A = char of interest
                                ; Exit:  C=0 if alpha, C=1 if not alpha
                bcc L9265       ; taken if alpha
                dey

L9271:
                iny
                dex

L9273:
                inx
                lda command_table,x
                bpl L9273
                clc

done:
                rts
                .endblock

;-------------------------------------------------------------------------

; Check if char is alphabetic
; Entry: A = char of interest
; Exit:  C=0 if alpha, C=1 if not alpha

isalpha:        .block
                pha             ; store char
                and #$DF        ; convert lower case to upper case
                cmp #'A'
                bcc not_alpha   ; taken if not alpha
                cmp #'Z'+1
                bcc done        ; taken if alpha

not_alpha:
                sec

done:
                pla             ; restore char
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Print 0-terminated string following call.
;
; Preserves: X
print_following_string: .proc
                .section print_following_string_workspace
pfs_ptr: .fill 2
                .endsection

loop:
                ; inc address on stack and store in pfs_ptr
                clc
                pla
                adc #1
                sta pfs_ptr+0
                tay
                pla
                adc #0
                sta pfs_ptr+1
                pha
                tya
                pha

                ; fetch next byte from string
                ldy #0
                lda (pfs_ptr),y
                beq done
                jsr oswrch
                jmp loop

done:
                rts
                
                .endproc                

;-------------------------------------------------------------------------
;
; Return value indicating whether hardware type is valid.
;
; Exit: C=1 if valid type:
;            V=0 if Electron
;            V=1 if Master
;       C=0 if invalid type
; Preserves: A/X/Y
;-------------------------------------------------------------------------

is_valid_hw: .proc
                pha
                txa
                pha
                tya
                pha
                ; https://beebwiki.mdfs.net/OSBYTE_%2600
                lda #0
                ldx #1
                jsr osbyte
                cpx #0
                beq electron
                cpx #3
                beq master
                ; Not valid
                clc
                jmp done

electron:
                clv
                bvc done        ;i.e., JMP
master:
                bit $8003       ;set V - there's a $4c there
done:
                pla
                tay
                pla
                tax
                pla
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Check valid hardware, doing a BRK if not valid.
;
; Exit: C=1 - same as is_valid_hw
;       Will do a BRK if any other values
;
must_be_valid_hw: .proc
                jsr is_valid_hw
                bcc error
                rts
error:
                ldx #errors_table.incompatible_hw_offset
                jmp do_error
                
                .endproc

;-------------------------------------------------------------------------

                .section read_or_write_state_workspace
state_ptr: .fill 2
                .endsection
                
;-------------------------------------------------------------------------
;
; Read 1 byte from the ROM state.
;
; Entry: Y = offset into State struct
; Exit: A = value read
; Preserves: X/Y
read_state: .proc
                jsr must_be_valid_hw
                bvs master

read_state_electron:
                stx state_ptr+0
                ldx elk_state_offsets,y
                lda $200,x
                ldx state_ptr+0
                rts

master:
                .cpu '65c02'
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+1
                stz state_ptr+0
                plx
                lda (state_ptr),y
                .cpu 'default'
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Write 1 byte to the ROM state.
;
; Entry: A = value to write
;        Y = offset into State struct
; Preserves: A/X/Y
write_state: .proc
                jsr must_be_valid_hw
                bvs master

                stx state_ptr+0
                ldx elk_state_offsets,y
                sta $200,x
                ldx state_ptr+0
                rts

master:
                .cpu '65c02'
                pha
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+1
                stz state_ptr+0
                plx
                pla
                sta (state_ptr),y
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------

elk_state_offsets: .proc
                .byte <elk_jflags
                .byte <elk_up
                .byte <elk_down
                .byte <elk_left
                .byte <elk_right
                .byte <elk_fire
                .endproc
                
;-------------------------------------------------------------------------
;
; Read 8-bit integer from string.
;
; Entry: ($f2),y = pointer to string
; Exit: A = LSB of value read
;       ($f2),y = pointer to remainder of string
; Preserves: X
                .section strtoi_workspace
strtoi_value: .fill 2
                .endsection
                
strtoi:         .proc
                jsr find_string_tail
                beq bad_hex
                lda #0
                sta strtoi_value+0
                sta strtoi_value+1
                jsr gsread      ; EAUG p12
                bcs bad_hex     ; taken if eol
                cmp #'&'
                bne decimal
; hex value
                jsr gsread
                bcs bad_hex     ; taken if eol
                bcc got_digit   ; JMP, in effect

hex_loop:
                jsr gsread
                bcs done        ; taken if eol

got_digit:
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex     ; taken if input error
; strtoi_value<<=4
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value|=digit
                adc strtoi_value+0
                sta strtoi_value+0
                bcc hex_loop    ; always a JMP???

done:
                lda strtoi_value+0
                rts

;-------------------------------------------------------------------------

bad_hex:
                ldx #errors_table.bad_hex_offset
                jmp do_error

;-------------------------------------------------------------------------

decimal:
                cmp #'-'
                php             ; save negative flag - Z=1 if negative
                bne decimal_loop
                jsr gsread
                bcs bad_hex

decimal_loop:
                jsr atoi_1_digit; Convert 1 decimal digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex
                pha             ; save digit value
                lda strtoi_value+1
                pha             ; save value MSB
                lda strtoi_value
; strtoi_value=strtoi_value*2
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=strtoi_value*2+strtoi_value -> strtoi_value*5
                adc strtoi_value+0
                sta strtoi_value+0
                pla             ; restore value MSB
                adc strtoi_value+1
                sta strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=(strtoi_value*2+strtoi_value)*2 -> strtoi_value*5*2 -> strtoi_value*10
                asl strtoi_value
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; add in digit
                pla             ; restore digit value
                adc strtoi_value+0
                sta strtoi_value+0
                bcc L953D
                inc strtoi_value+1
                beq bad_hex     ; taken if overflow

L953D:
                jsr gsread
                bcc decimal_loop; taken if not eol
                plp             ; restore negative flag
                bne L9552    ; taken if positive
; strtoi_value=-strtoi_value
                sec
                lda #0
                sbc strtoi_value+0
                sta strtoi_value+0
                lda #0
                sbc strtoi_value+1
                sta strtoi_value+1

L9552:
                lda strtoi_value+0
                rts
                .endproc

;-------------------------------------------------------------------------

; Convert 1 decimal digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
atoi_1_digit:   .block
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs L955C
                cmp #$A

L955C:
                rts
                .endblock

;-------------------------------------------------------------------------

; Convert 1 hex digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
xtoi_1_digit:   .block
                cmp #'A'
                bcc L9563
                sbc #7

L9563:
                sec
                sbc #'0'
                cmp #$10
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Restore default BYTEV and KEYV vectors.
;
; Preserves: P/A/X/Y

reset_default_vectors: .proc
                .section reset_default_vectors_workspace
rdv_ptr: .fill 2
                .endsection
                
                php
                sei
                tya
                pha

                lda default_vectors_ptr+0
                sta rdv_ptr+0
                lda default_vectors_ptr+1
                sta rdv_ptr+1

                ldy #<bytev
                jsr restore_default_vector

                ldy #<keyv
                jsr restore_default_vector

                pla
                tay
                plp
                rts

restore_default_vector:
                jsr restore_default_vector_byte
restore_default_vector_byte:
                lda (rdv_ptr),y
                sta $200,y
                iny
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Exit: Stack = [old_ACCCON old_P]
;       IRQs disabled
;       (os_seiwk) points to workspace
; Preserves: A/X/Y
setup_acccon_master: .proc
                .cpu '65c02'
                pha
                php
                pha
                phx
                tsx

                ;
                ; | Addr   | Before | After |
                ; |--------|--------|-------|
                ; | $101,x | old X  | old X
                ; | $102,x | old A  | old A
                ; | $103,x | old P  | retL
                ; | $104,x | old A  | retH
                ; | $105,x | retL   | old ACCCON
                ; | $106.x | retH   | old P

                lda $106,x
                sta $104,x
                lda $103,x
                sta $106,x
                lda $105,x
                sta $103,x
                lda acccon
                sta $105,x

                sei
                lda #acccon.ifj|acccon.y
                tsb acccon

                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0

                pla
                plx
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick: .proc
                jsr is_valid_hw
                lda #0
                bcc done
                bvc read_joystick_elk
                bvs read_joystick_master
done:
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Master.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_master: .proc
                .cpu '65c02'
                php
                sei
                lda acccon
                pha
                lda #acccon.ifj
                tsb acccon
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                plx
                stx acccon
                plp
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Electron.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_elk:
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                rts

joystick_fred_offsets:
                .byte $c0,$d0,$e0,$f0

joystick_action_masks:
                .byte %00000001
                .byte %00000010
                .byte %00000100
                .byte %00001000
                .byte %00010000
                
;-------------------------------------------------------------------------
;
; Read a (short - max 5 chars) line
;
; Exit: $line_input_data = input read
; 
read_line: .proc
                lda #<line_input_data
                sta line_input_pblock+0
                lda #>line_input_data
                sta line_input_pblock+1
                lda #5
                sta line_input_pblock+2
                lda #32
                sta line_input_pblock+3
                lda #127
                sta line_input_pblock+4
                ldx #<line_input_pblock
                ldy #>line_input_pblock
                lda #0
                jmp osword
                .endproc

;-------------------------------------------------------------------------
;
;
print_hex_byte: .proc
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr nybble
                pla
                pha
                and #$0f
                jsr nybble
                pla
                rts

nybble:
                sed
                clc
                adc #$90
                adc #$40
                cld
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------

                .endsection code

;-------------------------------------------------------------------------
