                .include "submodules/beeb/include/beeb.s65"
                .edef '\\','\'

fall_through_to: .macro dest
                .cerror *!=\dest,'fallthrough broke...'
                .endmacro

;-------------------------------------------------------------------------

default_vectors_ptr=$ffb7

os_a=$ef ; A value for osbyte/osword
os_x=$f0 ; X value for osbyte/osword
os_y=$f1 ; Y value for osbyte/osword

; seems to be relatively safe to use for brief periods with IRQs
; disabled
os_seiwk=$fa

; only safe to use with IRQs disabled!
os_seia=$fc

; Fortunately the same on Electron OS 1.00 and Master MOS.
os_auto_repeat_countdown=$e7
os_auto_repeat_period=$255
                
; Routines that do PLA:<<restore ROM>>:PLA:PLP:RTS - as is part of the
; extended vector handling mechanism.
os_restore_rom_master=$ffa4
os_restore_rom_electron=$ff9c

;-------------------------------------------------------------------------

; MOS variables
os_tab_key_code=$26b            ;OSBYTE 219 ($db)
                
;-------------------------------------------------------------------------
;
; See https://beebwiki.mdfs.net/OSBYTEs

; Placeholder OSBYTE used to indicate that the ROM is actually being
; entered due to KEYV.
keyv_osbyte=83

;-------------------------------------------------------------------------

brkbuf=$100

                .if debug
rom_name='ADJI (debug) '..debug_time
                .else
rom_name='ADJI'
                .endif
rom_ver='0.03'

default_overlay_address=$150
                
; Up=0, Down=1, Left=2, Right=3, Fire1=4, Fire2=5
num_actions=6

;-------------------------------------------------------------------------
;
; ROM state logical layout. Pass offsets into this struct into
; read_state/write_state.
; 
State: .struct
jflags: .block
                
; Index of joystick interface to use.
jindex_mask=%00000011
                
; If set, treat joystick inputs as keyboard inputs.
jkeys_mask=%00000100
                
; If set, treat joystick inputs as analogue inputs.
jjoy_mask=%01000000
                .fill 1
                .endblock
; Keys are stored as internal key numbers. See AUG p 142.
action_keys: .fill num_actions
                .endstruct
                .cerror State.jflags!=0,'State jflags must be at offset 0'

;-------------------------------------------------------------------------
;
; ROM state on Master 128 is stored in a page in HAZEL. Layout just as
; per the struct.
;

; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
; master_spare=$0261

;-------------------------------------------------------------------------
;
; ROM state on Electron.
;
; The various bytes are stored in page 2, in locations that Electron
; OS 1.00 doesn't use.
;
; $0290 is used by the Slogger Electron Expansion ROM as follows:
;
; bit 6 = ADC/digital joystick select
; bits 0/1 = digital joystick index
;
; The ADJI ROM jflags are compatible.
;
; Also unused on Electron:
;
; $0261 - "speech suppression status" - unused in practice?
; $0282 - used by MRB??
; $028a - used by MRB??
; $028b - used by MRB??
; 
elk_jflags=$0290                ;unused by Electron OS
elk_up=$02a8                    ;ROM flags for keyboard
elk_down=$02a9                  ;ROM flags for keyboard
elk_left=$02aa                  ;ROM flags for lower-priority BASIC
elk_right=$02f5                 ;unused by Electron OS
elk_fire1=$02f6                 ;unused by Electron OS
elk_fire2=$027e                 ;unused by Electron OS

;-------------------------------------------------------------------------

machine_type_other=0
machine_type_electron=1
machine_type_master=2

jup_mask=1
jdown_mask=2
jleft_mask=4
jright_mask=8
jfire1_mask=16
jfire2_mask=32
jall_mask=jfire2_mask|jfire1_mask|jright_mask|jleft_mask|jdown_mask|jup_mask
                
;-------------------------------------------------------------------------

struct_section: .macro
                .struct
                .dsection \1
                .ends
                .endmacro

*=$a8
                ; Leaf routines that only use transient zp workspace
                .union
                .endunion

                ; Leaf routines that return a result in zero page
                .union
                .struct_section strtoi_workspace
                .endunion

                ; * commands
                .union
                .struct_section cmd_jtest_workspace
                .struct_section cmd_jjoy_workspace
                .struct_section cmd_jkeys_workspace
                .struct_section cmd_jsetup_workspace
                .endunion
                
                .cerror *>$b0,'zp overflow'

;-------------------------------------------------------------------------

*=$b0
                ; Leaf routines that only use transient zp workspace
                ; and make no FS calls (or can survive their workspace
                ; being zapped if one is made).

                ; Leaf functions
                .union
                .struct_section print_following_string_workspace
                .struct_section reset_default_vectors_workspace
                .struct_section read_or_write_state_workspace
                .struct_section find_command_workspace
                .struct_section print_joystick_action_name_workspace
                .endunion
                
                .struct_section install_xvector_workspace
                .struct_section set_jkeys_mode_workspace
                .struct_section verbose_get_key_workspace
                .struct_section question_workspace
                .cerror *>$c0,'FS scratch zp overflow'

;-------------------------------------------------------------------------

*=$8000
                .dsection header
                .dsection tables
                .dsection service
                .dsection star
                .dsection common
                .dsection master_only
                .dsection library
                
                .if debug
                ; The debug ROM is for loading into sideways RAM or
                ; similar, and can occupy the full 16 KB.
                .cerror *>$c000,'code overflow'
                .else
                ; The real ADJI ROM is 4 KB.
                .cerror *>$9000,'code overflow'
                .endif
                
;-------------------------------------------------------------------------
                .section header
;-------------------------------------------------------------------------

rom_header:
                .byte 0,0,0     ;language entry (none)
                jmp svc         ;service entry
                .byte $82       ;ROM type: service entry, 6502 code
                .byte <rom_copyright
                .byte 0
rom_title:
                .text rom_name
                .byte 0
rom_version:
                .text rom_ver
rom_copyright:
                .byte 0
                .text '(C) 2023 Retro Hardware'
rom_copyright_end:
                .byte 0
;-------------------------------------------------------------------------
                .endsection header
;-------------------------------------------------------------------------
                .section tables
;-------------------------------------------------------------------------
command_table_entry: .function name,routine,help_offset
_start:
                .cerror (routine&$8000)==0,'routine address bit 15 must be set'
                .text name
                .byte >(routine-1)
                .byte <(routine-1)
                .byte help_offset
                .endfunction _start-command_table
                
command_table: .block
subjects_offset=*-command_table
                .command_table_entry "ADJI",help_adji,help_table.none_offset
                .byte 0
cmds_offset=*-command_table
                .command_table_entry "JJOY",cmd_jjoy,help_table.jjoy_offset
                .command_table_entry "JOFF",cmd_joff,help_table.none_offset
                .command_table_entry "JKEYS",cmd_jkeys,help_table.jkeys_offset
                .command_table_entry "JSETUP",cmd_jsetup,help_table.none_offset
                .if debug
                .command_table_entry "JSTATE",cmd_jstate,help_table.none_offset
                .endif
                .command_table_entry "JTEST",cmd_jtest,help_table.jtest_offset
                .if debug
                .command_table_entry "KTEST",cmd_ktest,help_table.none_offset
                .endif
                .byte 0
                .endblock

help_table: .block
jtest_offset=*-help_table
                .text ' <no>'
none_offset=*-help_table
                .text 0
jjoy_offset=*-help_table
                .text ' <no> X|<addr>',0
jkeys_offset=*-help_table
                .text ' <no> <up> <down> <left> <right> <fire1> <fire2> X|<addr>',0
                .endblock

;-------------------------------------------------------------------------

error_table_entry: .function err,text
_start:
                .byte err
                .text text
                .byte 0
                .endfunction _start-errors_table

errors_table: .block
bad_hex_offset: .error_table_entry $fe,'Bad hex'
incompatible_hw_offset: .error_table_entry $ff,'Electron/Master 128 only'
bad_jno_offset: .error_table_entry $dc,'Bad joystick'
no_free_hazel: .error_table_entry $ff,'No free FS RAM'
bad_mode: .error_table_entry $ff,'Bad mode'
todo_offset: .error_table_entry $ff,'TODO'
electron_todo_offset: .error_table_entry $ff,'Electron = TODO'
                .endblock
                
;-------------------------------------------------------------------------

                .include "build/generated_key_tables.s65"

;-------------------------------------------------------------------------

joystick_actions: .block
masks:
                .byte jup_mask
                .byte jdown_mask
                .byte jleft_mask
                .byte jright_mask
                .byte jfire1_mask
                .byte jfire2_mask
names:
                ;      01234
                .text "     "
                .text "UP   "
                .text "DOWN "
                .text "LEFT "
                .text "RIGHT"
                .text "FIRE1"
                .text "FIRE2"
                .endblock

;-------------------------------------------------------------------------

elk_state_offsets: .proc
                .byte <elk_jflags
                .byte <elk_up
                .byte <elk_down
                .byte <elk_left
                .byte <elk_right
                .byte <elk_fire1
                .byte <elk_fire2
                .endproc
                
joystick_fred_offsets:
                .byte $c0,$d0,$e0,$f0

;-------------------------------------------------------------------------

questions_table: .proc
jno=*-questions_table
                .shiftl "Joystick no"
                .shiftl "1/2/3/4"
jk=*-questions_table
                .shiftl "Joystick/Keys"
                .shiftl "J/K"
xo=*-questions_table
                .shiftl "Xvector/Overlay"
                .shiftl "X/O"
                .endproc
                
;-------------------------------------------------------------------------
                .endsection tables
;-------------------------------------------------------------------------
                .section service
;-------------------------------------------------------------------------

svc: .proc
                cmp #$15
                beq done2       ;fast path for 100 Hz polling
                                ;interrupt
                pha
                cmp #4
                beq star
                cmp #9
                beq help
                ; https://beebwiki.mdfs.net/Using_high_workspace
                cmp #$22
                beq claim_hazel
                cmp #$24
                beq count_hazel
unclaimed:
                pla
done:
                ldx $f4
done2:
                rts

claimed:
                pla
                lda #0
                beq done    ;i.e., JMP

count_hazel:
                dey             ;1 page required
                jmp unclaimed

claim_hazel:
                tya
                cmp #$dc        ;run out of HAZEL space?
                bcc +           ;taken if not run out
                lda #0          ;indicate workspace unavailable
+
                sta $df0,x
                iny             ;claim 1 page
                jmp unclaimed
                
help:
                tya
                pha
                jsr find_string_tail
                bcs no_help_subject ;taken if command line empty
                ldx #command_table.subjects_offset
                pla
                pha
                tay
                jsr find_command ;try to find subject
                bcc found_subject
                ; Command line not for us - do nothing and pass on.
pla_tay_unclaimed:
                pla
                tay
                jmp unclaimed

no_help_subject:
                jsr print_help_banner
                ldx #command_table.subjects_offset
                jsr print_help
                jmp pla_tay_unclaimed

found_subject:
                jsr print_help_banner
                sec
                jsr call_command_table_routine
                jmp pla_tay_unclaimed

star:
                tya
                pha
                ldx #command_table.cmds_offset
                jsr find_command
                bcc found_command
                jmp pla_tay_unclaimed
                
found_command:
                clc
                jsr call_command_table_routine
                pla
                tay
                jmp claimed

print_help_banner .proc
                jsr osnewl
                ldy #<rom_title
-
                lda rom_header,y
                bne +
                lda #' '
+
                jsr oswrch
                iny
                cpy #rom_copyright-rom_header
                bne -
                rts
                
                .endproc
                
                .endproc

;-------------------------------------------------------------------------

help_adji: .proc
                ldx #command_table.cmds_offset
                jmp print_help
                .endproc

;-------------------------------------------------------------------------
;
; Print help for part of the commands table.
;
; Entry: X = offset of first command
;
print_help: .proc
                jsr osnewl
cmds_loop:
                lda command_table,x
                beq done
                lda #' '
                jsr oswrch
                jsr oswrch
cmd_name_loop:
                lda command_table,x
                bmi name_done
                jsr oswrch
                inx
                bne cmd_name_loop
name_done:
                inx
                inx
                ldy command_table,x
                inx
help_loop:
                lda help_table,y
                beq next
                jsr oswrch
                iny
                bne help_loop
next:
                jsr osnewl
                jmp cmds_loop
done:
                rts
                .endproc
;-------------------------------------------------------------------------
                .endsection service
;-------------------------------------------------------------------------
                .section star
;-------------------------------------------------------------------------
cmd_joff:
                jsr reset_default_vectors
                rts

;-------------------------------------------------------------------------
                
cmd_jjoy: .proc
                .section cmd_jjoy_workspace
joystick_index: .fill 1
yval: .fill 1
                .endsection

                jsr must_be_valid_hw

                jsr reset_default_vectors

                jsr parse_jno
                sta joystick_index

                sty yval

                lda joystick_index
                ora #State.jflags.jjoy_mask
                jsr set_jflags
                
                ldy yval
                .fall_through_to handle_install_mode
                .endproc

handle_install_mode: .proc
                jsr find_string_tail
                bcc +

                ldx #errors_table.bad_mode
                jmp do_error

+
                and #$df
                cmp #'X'
                beq install_xvector
                jsr strtoi
                jmp install_overlay
                .endproc

;-------------------------------------------------------------------------

cmd_jkeys: .proc
                .section cmd_jkeys_workspace
index: .fill 1
yval: .fill 1
state_index: .fill 1
                .endsection

                jsr parse_jno
                sty yval

                ora #State.jflags.jkeys_mask
                jsr set_jflags

                lda #State.action_keys
                sta index

loop:
                ldy yval
                jsr strtoi
                sty yval

                ; convert to internal key number
                eor #$ff
                and #$7f

                ldy index
                jsr write_state

                iny
                sty index
                cpy #State.action_keys+num_actions
                bne loop

                ldy yval
                jmp handle_install_mode
                .endproc

;-------------------------------------------------------------------------

cmd_jsetup: .proc
input_block=$150
input_buffer=$155
                .section cmd_jsetup_workspace
jno: .fill 1
jkeys: .fill 1
use_overlay: .fill 1
action_index: .fill 1
                .endsection

                jsr reset_default_vectors

                ldx #questions_table.jno
                jsr question
                bcs done
                sty jno

                ldx #questions_table.jk
                jsr question
                bcs done
                sty jkeys
                tya
                bne keys        ;taken if keys

joy:
                jsr hook_question
                bcs done
                
                jsr print_following_string
                .text '*JJOY ',0

                jsr print_jno
                jsr print_hook_info
install:
                lda jno
                ora #State.jflags.jjoy_mask ;assume joystick mode
                ldx jkeys
                beq +           ;taken if joystick mode

                ; clear jjoy flag, set jkeys flag
                eor #State.jflags.jjoy_mask|State.jflags.jkeys_mask
+
                jsr set_jflags
                lda use_overlay
                beq install_xvector
                jmp install_overlay

keys:
                lda #0
                sta action_index
actions_loop:
                jsr print_following_string
                .text 'Press ',0

                ldx action_index
                jsr print_joystick_action_name

                jsr print_following_string
                .text ': ',0

                jsr verbose_get_key

                bit $ff
                bmi done

                jsr osnewl

                clc
                lda action_index
                adc #State.action_keys
                tay             ;Y=state offset

                txa             ;A=INKEY
                eor #$ff        ;A=internal key value
                jsr write_state

                inc action_index
                lda action_index
                cmp #num_actions
                bne actions_loop

                ; Clear buffers
                lda #15
                ldx #0
                jsr osbyte

                jsr hook_question

                bit $ff
                bmi done

                ; Print *JKEYS command line
                jsr print_following_string
                .text '*JKEYS ',0

                lda jno
                clc
                adc #'1'
                jsr oswrch

                ldx #State.action_keys
print_keys_loop:
                jsr print_following_string
                .text ' &',0

                txa
                tay
                jsr read_state
                eor #$ff        ;convert to negative INKEY value
                jsr print_hex_byte

                inx
                cpx #State.action_keys+num_actions
                bne print_keys_loop

                jsr print_hook_info
                jmp install
                
done:
                rts

hook_question:
                ldx #questions_table.xo
                jsr question
                bcs done
                sty use_overlay
                cpy #0
                beq done        ;bail if xvector

                jsr print_following_string
                .text 'Overlay addr (default: &',format('%X',default_overlay_address),'): ',0

                ; seems to be usual to put the parameter block in main
                ; RAM, rather than referring to one in the ROM?
                ldy #4
-
                lda osword_block,y
                sta input_block,y
                dey
                bpl -

                ldx #<input_block
                ldy #>input_block
                lda #0
                jsr osword
                bcs done

                lda #<default_overlay_address
                sta strtoi_value+0
                lda #>default_overlay_address
                sta strtoi_value+1
                
                lda #<input_buffer
                sta $f2
                lda #>input_buffer
                sta $f3
                ldy #0
                jsr find_string_tail
                bcs done        ;taken if empty input - use default
                jmp strtoi
                
print_jno:
                lda jno
                clc
                adc #'1'
                jmp oswrch

print_hook_info:
                lda #' '
                jsr oswrch
                lda use_overlay
                bne print_overlay_addr
                ; using xvector
                lda #'X'
                jsr oswrch
                jmp osnewl
print_overlay_addr:
                lda #'&'
                jsr oswrch
                lda strtoi_value+1
                jsr print_hex_byte
                lda strtoi_value+0
                jsr print_hex_byte
                jmp osnewl

osword_block:
                .word input_buffer ;buffer address
                .byte 5            ;max length
                .byte 32           ;min ASCII
                .byte 127          ;max ASCII
                
                .endproc
;-------------------------------------------------------------------------

cmd_jtest: .proc
                .section cmd_jtest_workspace
joystick_index: .fill 1
action_index: .fill 1
jvalue: .fill 1
                .endsection
                
                jsr parse_jno
                sta joystick_index
                
                jsr print_following_string
                .text 22,135
                .text 31,8,1
                .text "J O Y S T I C K   T E S T"
                .byte 0

                jsr coff

loop:
                bit $ff
                bmi done        ;taken if Escape pressed

                ldx joystick_index
                jsr read_joystick
                sta jvalue

                jsr print_following_string
                .text 31,5,5,"Raw value: &",0

                lda jvalue
                jsr print_hex_byte

                jsr print_following_string
                .text " (%",0

                ldx #8
                ldy jvalue
binary_loop:
                tya
                asl a
                tay

                lda #'0'
                adc #0
                jsr oswrch

                dex
                bne binary_loop

                jsr print_following_string
                .text ")",0

                lda #num_actions-1
                sta action_index
check_actions:
                
                jsr print_following_string
                .byte 31,17,0
                
                lda action_index
                clc
                adc #10         
                jsr oswrch      ;PRINT TAB(17,Y)

                lda jvalue

                ldx action_index
                and joystick_actions.masks,x
                bne +
                ldx #$ff        ;no action
+
                jsr print_joystick_action_name

                dec action_index
                bpl check_actions
                jmp loop

done:
                jsr con
                lda #$7e
                jsr osbyte
                lda #12
                jmp oswrch
                
                .endproc

;-------------------------------------------------------------------------

cmd_ktest: .proc
                jsr print_following_string
                .text 'Press keys',0

ktest_loop:
                jsr print_following_string
                .text ' | ',0

                jsr verbose_get_key

                bit $ff
                bpl ktest_loop

                lda #15
                ldx #0
                jmp osbyte
                
                .endproc

;-------------------------------------------------------------------------

cmd_jstate: .proc
                ldx #0
loop:
                jsr print_following_string
                .text '+&',0

                txa
                jsr print_hex_byte

                jsr print_following_string
                .text ': &',0

                txa
                tay
                jsr read_state
                jsr print_hex_byte

                jsr osnewl

                inx
                cpx #size(State)
                bne loop
                rts
                .endproc
                
;-------------------------------------------------------------------------
                .endsection star
;-------------------------------------------------------------------------
                .section common
;-------------------------------------------------------------------------
;
; Install overlay routines.
;
; Entry: (strtoi_value) = dest pointer
;        state jflags
; 
install_overlay: .proc
                jsr must_be_valid_hw
                bvs +
                ldx #errors_table.electron_todo_offset
                jmp do_error
+
                ldy #size(overlay_master)-1
loop:
                lda overlay_master,y
                sta (strtoi_value),y
                dey
                bpl loop

                ; Fix up ROMSEL value.
                ldy #overlay_master.rom_offset
                lda $f4
                sta (strtoi_value),y

                ; Fix up workspace page.
                tay
                lda $df0,y
                ldy #overlay_master.workspace_page
                sta (strtoi_value),y

                ; Point BYTEV to the right place.
                lda #overlay_master.osbyte_entry_offset
                ldx #<bytev
                jsr set_overlay_vector

                ; Maybe point KEYV to the right place.
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask
                beq keyv_done
                lda #overlay_master.keyv_entry_offset
                ldx #<keyv
                jsr set_overlay_vector
keyv_done:

                rts

set_overlay_vector:
                php
                sei
                clc
                adc strtoi_value+0
                sta $200,x
                lda strtoi_value+1
                adc #0
                sta $201,x
                plp
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Install xvector routines.
;
; Entry: state jflags
install_xvector: .proc
                .section install_xvector_workspace
xvectors: .fill 2
                .endsection
                lda #$a8        ;read extended vector table address
                jsr osbyte_x00_yff
                ; ldx #$00
                ; ldy #$ff
                ; jsr osbyte
                stx xvectors+0
                sty xvectors+1

                jsr must_be_valid_hw
                bvs +           ;taken if Master 128
                ldx #errors_table.electron_todo_offset
                jmp do_error
+

                php
                sei

                ; BYTEV
                lda #$ff
                sta bytev+1
                ldy #(<bytev)/2*3
                sty bytev+0
                lda #<handle_osbyte_xvector_master
                sta (xvectors),y
                iny
                lda #>handle_osbyte_xvector_master
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y

                ; KEYV
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask
                beq keyv_done

                lda #$ff
                sta keyv+1
                ldy #(<keyv)/2*3
                sty keyv+0
                lda #<handle_keyv_xvector_master
                sta (xvectors),y
                iny
                lda #>handle_keyv_xvector_master
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y
keyv_done:
                
                plp
                rts
                .endproc
;-------------------------------------------------------------------------
                .endsection common
;-------------------------------------------------------------------------
                .section master_only
;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine for Master 128.
;
; Entry: A/X/Y/P as per OSBYTE or KEYV (according to entry point)
;
overlay_master: .block
                .cpu '65c02'
keyv_entry_offset=*-overlay_master
                lda #keyv_osbyte
osbyte_entry_offset=*-overlay_master
                php
                sei
                pha             ;save input A
rom_offset=*+1-overlay_master
                lda #$ff
                sta $fe30
workspace_page=*+1-overlay_master
                lda #$ff
                jmp handle_overlay_master
                .endblock

                ; Unlikely
                .cerror size(overlay_master)>128,'overlay too large'

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine suffix for Master 128
;
; Entry: A = workspace address MSB
;        X/Y = as per OSBYTE
;        IRQs disabled
;        Stack = [A, P, OSBYTE ret]
; 
handle_overlay_master:
                ; Store workspace address MSB.
                sta os_seiwk+1

                ; Save input A.
                pla
                sta os_seiwk+0

                ; Save input P.
                pla
                sta os_seia

                ; Save previous ROMSEL.
                lda $f4
                pha
                
                ; Make ROMSEL and $f4 consistent.
                lda $fe30
                sta $f4

                ; Insert overlay exit routine addres.
                lda #>handle_overlay_exit_master-1
                pha
                lda #<handle_overlay_exit_master-1
                pha

                ; Put input P back on stack.
                lda os_seia
                pha

                ; Reinstate input A.
                lda os_seiwk+0

                ; Form workspace address in (os_seiwk).
                stz os_seiwk+0

                jmp handle_osbyte_master

; Entry: A/X/Y/P as per OSBYTE return
; Stack: [old ROMSEL, return address]
handle_overlay_exit_master:
                .cpu '65c02'
                pha
                php
                phx
                tsx
                ; S = X P A ROMSEL RetL RetH
                lda $104,x      ;ROMSEL
                pha             ;S = ROMSEL | X P A ROMSEL RetL RetH
                lda $102,x      ;P
                sta $104,x      ;S = ROMSEL | X P A P RetL RetH
                pla             ;S = | X P A P RetL RetH
                sta $102,x      ;S = | X ROMSEL A P RetL RetH
                plx             ;S = ROMSEL A P RetL RetH
                jmp os_restore_rom_master
                .cpu 'default'

;-------------------------------------------------------------------------
;
; Handle OSBYTE on Master 128 when called via extended vector.
;
; Entry: A/X/Y = as per OSBYTE
; 
handle_osbyte_xvector_master: .proc
                .cpu '65c02'
                php
                sei
                pha
                phx
                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0
                plx
                pla
                jmp handle_osbyte_master
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; KEYV xvector handler for Master 128
;
; Entry: just as per KEYV
handle_keyv_xvector_master: .proc
                .cpu '65c02'
                php
                sei
                pha
                phx
                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0
                plx
                pla
                jmp keyv_master
                .cpu 'default'                
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV handler for Master 128
; 
; Entry: A, X, Y = OSBYTE/KEYV entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]

handle_osbyte_master:
                ; Don't use the OSBYTE zero page yet - it might be
                ; KEYV, possibly called from an interrupt context.
                cmp #keyv_osbyte
                beq keyv_master

                ; This is OSBYTE.
                sta os_a
                stx os_x
                sty os_y

                cmp #$80
                beq osbyte_80_master

                cmp #$81
                beq osbyte_81_master
osbyte_unhandled:
                ldx os_x
                ldy os_y
                plp
                jmp jmp_default_osbyte

;-------------------------------------------------------------------------
;
; OSBYTE $81 handler for Master 128.
;
; Entry: A = $81, ?os_a = $81
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
;
osbyte_81_master: .proc
                .cpu '65c02'

                ; Skip if jkeys bit not set.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda (os_seiwk)
                and #State.jflags.jkeys_mask
                cmp #1          ;C=1 if set
                pla
                sta acccon

                ; Defer to default OSBYTE if jkeys off.
                ldx os_x
                lda os_a
                ldy os_y
                bcc jmp_default_osbyte.with_p_already_pushed

                ; Go to timeout case if Y<$80
                bpl timeout

                ; Call default OSBYTE if Y!=$ff
                cpy #$ff
                bne jmp_default_osbyte.with_p_already_pushed

                ; Call default OSBYTE for the X=$00 Y=$FF version
                ; call.
                cpx #0
                beq jmp_default_osbyte.with_p_already_pushed

                ; Is this one of the jkeys?
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda #1
                sta os_y
                ldy #State.action_keys

                lda os_x
                eor #$ff        ;convert to internal key
poll_key_loop:
                cmp (os_seiwk),y
                beq found_key
                asl os_y
                iny
                cpy #State.action_keys+num_actions
                bne poll_key_loop
not_found_key:
                pla
                sta acccon

                lda #$81
                ldy #$ff
                ldx os_x
                
                jmp jmp_default_osbyte.with_p_already_pushed

found_key:
                lda (os_seiwk)
                and #3
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                and os_y
                beq not_found_key

                pla
                sta acccon
                ldx #$ff
                ldy #$ff
                lda #$81
                plp
                rts

timeout:
                ; 
                ; Form negated timeout in Y/X.
                tya
                eor #$ff
                tay
                txa
                eor #$ff
                tax

loop:
                ; Save timeout.
                pla             ;old IRQ state [RL RH]
                pha             ;save old IRQ state [P RL RH]
                phy             ;[Y P RL RH]
                phx             ;[X Y P RL RH]
                pha             ;save old IRQ state again [P X Y P RL RH]

                ; Read joystick.
                lda acccon
                pha             ;[ACCCON P X Y P RL RH]
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda (os_seiwk)
                and #3
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                and #jall_mask
                beq try_osbyte  ;taken if obviously nothing pressed

                ; Find state offset for action.
                ;
                ; TODO: there'll probably be room to have this in a
                ; table.
                ldy #State.action_keys-1
find_index_loop:
                iny
                lsr a
                bcc find_index_loop

                lda (os_seiwk),y
                bpl jkey_pressed
                
try_osbyte:
                pla             ;[P X Y P RL RH]
                sta acccon
                
                lda os_seiwk+1
                plp             ;Restore IRQ state [X Y P RL RH]
                pha             ;Save workspace ptr MSB [WH X Y P RL RH]

                ldy #0
                ldx #1
                lda #$81
                jsr jmp_default_osbyte
                cpy #$ff
                bne kkey_pressed

                ; lda #1
                ; sta os_auto_repeat_countdown

                ; Restore state.
                pla             ;Restore workspcae ptr MSB [X Y P RL RH]
                sei
                sta os_seiwk+1
                stz os_seiwk+0

next:
                ; Increment timeout, and keep going until 0.
                plx             ;[Y P RL RH]
                ply             ;[P RL RH]
                
                inx
                bne loop
                iny
                bne loop

                ; X=0, Y=0. Timed out. Return with C=1 and Y=$ff.
                plp             ;[RL RH]
                dey
                sec
                rts
                .cpu 'default'

kkey_pressed:
                pla             ;discard workspace ptr MSB [X Y P RL RH]
                pla             ;discard counter LSB [Y P RL RH]
                pla             ;discard counter MSB [P RL RH]
                plp             ;restore IRQ state [RL RH]
                lda #$81        ;A is preserved
                clc
                rts

jkey_pressed:
                ldx os_auto_repeat_countdown
                beq reset_auto_repeat_countdown
                dec os_auto_repeat_countdown
                bne try_osbyte
reset_auto_repeat_countdown:
                ldx os_auto_repeat_period
                stx os_auto_repeat_countdown
                
                pha             ;save internal key number [K ACCCON P X Y P RL RH]
                lda #$ac        ;Keyboard translation table address
                                ;AUG p 183
                jsr osbyte_x00_yff
                ; ldx #$00
                ; ldy #$ff
                ; jsr osbyte
                sei
                stx os_seiwk+0  ;keyboard translation table LSB
                sty os_seiwk+1  ;keyboard translation table MSB
                pla             ;restore internal key number [ACCCON P X Y P RL RH]
                tay             ;Y=internal key number
                lda (os_seiwk),y
                bne +           ;taken if not TAB
                lda os_tab_key_code
+
                ; The Slogger ROM doesn't handle shift, ctrl, caps
                ; lock, etc., so this one doesn't either.
                jsr toupper
                
                tax             ;X = ASCII value of key pressed
                pla             ;get old ACCCON value [P X Y P RL RH]
                sta acccon
                pla             ;discard old IRQ state copy [X Y P RL RH]
                pla             ;discard counter LSB [Y P RL RH]
                pla             ;discard counter MSB [P RL RH]
                plp             ;restore old IRQ state [RL RH]
                lda os_a
                ldy #0
                clc
                rts
                
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE $80 handler for Master 128.
;
; Entry: A = $80, ?os_a = $80
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
; 
osbyte_80_master: .proc
                ; Bail if not ADVAL.
                ldx os_x
                cpx #5
                bcs osbyte_unhandled
                
                .cpu '65c02'
                ; Save old ACCCON. Page in HAZEL. Direct FRED to
                ; cartridge.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Fetch joystick index.
                ldy #State.jflags
                lda (os_seiwk),y
                bit #State.jflags.jjoy_mask
                beq default
                and #3

                ; ?os_a = joystick value
                tay
                lda joystick_fred_offsets,y
                tay
                lda $fc00,y
                sta os_a

                ; Restore old ACCCON.
                pla
                sta acccon

                ; OK to possibly re-enable IRQs now.
                plp
                
                jmp osbyte_80_generic
                .cpu 'default'

default:
                pla
                sta acccon
                lda os_a
                jmp osbyte_unhandled
                .endproc
;-------------------------------------------------------------------------
;
; KEYV handler for Master 128.
;
; Entry: A = keyv_osbyte
;        X, Y = KEYV arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
keyv_master: .proc
                .cpu '65c02'
                pla             ;restore P
                pha             ;re-save P
                and #%01000001  ;separate C+V
                cmp #%00000001  ;check for C=1 V=0
                beq scan

                ; Forward to default KEYV.
                jmp jmp_default_keyv.with_p_already_pushed

scan:
                sta os_a
                sty os_y
                
                ; Check for keyboard scan mode.
                txa
                bpl scan_multiple_keys ;taken if scanning for multiple
                                       ;keys

scan_single_key: .block
                ; Convert to internal key number.
                and #$7f
                sta os_x
                
                ; Set up ACCCON.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Read joystick flags into X
                lda (os_seiwk)
                bit #State.jflags.jkeys_mask
                beq default
                and #3
                tax
                ldy joystick_fred_offsets,x
                ldx $fc00,y

                ldy #State.action_keys+num_actions-1
loop:
                lda os_x        ;key of interest
                cmp (os_seiwk),y
                bne next        ;taken if not this jkey
                txa             ;get joystick flags
                and joystick_actions.masks-State.action_keys,y
                bne pressed     ;taken if this jkey pressed
next:
                dey
                bne loop

default:
                ; Restore ACCCON.
                pla
                sta acccon

                ; Key was not one of the joystick keys, so forward the
                ; call on to KEYV.
                lda os_x
                ora #$80        ;reinstate bit 7, masked out above
                tax
                lda os_a
                ldy os_y
                jmp jmp_default_keyv.with_p_already_pushed

pressed:
                ; Restore ACCCON.
                pla
                sta acccon

                ; Report key pressed.
                lda os_a
                ldx #$ff
                ldy os_y
                plp
                rts
                .endblock
                
scan_multiple_keys: .block
                phx
                lda os_seiwk+1
                pha
                sec
                clv
                jsr jmp_default_keyv

                ; Save KEYV result.
                stx os_y

                ; Restore old state: IRQs disabled, os_seiwk set up,
                ; os_x as per entry.
                sei
                stz os_seiwk+0
                pla
                sta os_seiwk+1
                pla
                sta os_x

                ; Set up ACCCON.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Read joystick flags.
                lda (os_seiwk)
                and #3
                tax
                ldy joystick_fred_offsets,x
                ldx $fc00,y
                ldy #State.action_keys+num_actions-1
loop:
                txa             ;A=joystick flags
                and joystick_actions.masks-State.action_keys,y
                beq next        ;taken if not pressed

                lda (os_seiwk),y ;get key for this action
                cmp os_x         ;within scan range?
                bcc next         ;taken if not
                beq next         ;taken if not
                cmp os_y         ;existing result covers it?
                bcs next         ;taken if so
                sta os_y

next:
                dey
                bne loop

                ; Restore old ACCCON.
                pla
                sta acccon

                ldx os_y
                lda os_a
                plp
                rts
                .endblock
                .endproc
;-------------------------------------------------------------------------
;
; Exit: Stack = [old_ACCCON old_P]
;       IRQs disabled
;       (os_seiwk) points to workspace
; Preserves: A/X/Y
setup_acccon_master: .proc
                .cpu '65c02'
                pha
                php
                pha
                phx
                tsx

                ;
                ; | Addr   | Before | After |
                ; |--------|--------|-------|
                ; | $101,x | old X  | old X
                ; | $102,x | old A  | old A
                ; | $103,x | old P  | retL
                ; | $104,x | old A  | retH
                ; | $105,x | retL   | old ACCCON
                ; | $106.x | retH   | old P

                lda $106,x
                sta $104,x
                lda $103,x
                sta $106,x
                lda $105,x
                sta $103,x
                lda acccon
                sta $105,x

                sei
                lda #acccon.ifj|acccon.y
                tsb acccon

                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0

                pla
                plx
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
                .endsection master_only
;-------------------------------------------------------------------------
                .section common
;-------------------------------------------------------------------------
;
; Entry: X = offset into questions table
; Exit: Y = index of option
;       C=1 if Escape pressed
question: .proc
                .section question_workspace
char_entered: .fill 1
                .endsection

                jsr print_string ;question

                txa
                pha             ;save options offset
                
                jsr print_following_string
                .text ' (',0

                jsr print_string ;options

                jsr print_following_string
                .text ')? ',0

read_option_loop:
                jsr osrdch
                bcs quit
                
                jsr toupper
                sta char_entered

                ; Y = option index
                ldy #0

                ; X = option offset
                pla
                pha
                tax
find_option_loop:
                lda questions_table,x
                lsr a
                php
                
                ; Cheaper to include the '/' in the option string, but
                ; now it does have to be excluded.
                cmp #'/'
                beq next
                
                cmp char_entered
                beq found

                iny
next:
                inx
                plp
                bcc find_option_loop
                bcs read_option_loop

found:
                jsr oswrch
                jsr osnewl
                pla             ;discard saved P
                clc             ;indicate Escape not pressed
quit:
                pla             ;discard saved options offset
                rts

print_string:
                lda questions_table,x
                jsr shiftl_oswrch
                inx
                bcc print_string
                rts
                
                .endproc

;-------------------------------------------------------------------------
;
; Call OSWRCH with a .shiftl char.
;
; Entry: A = shiftl char
; Exit: A = ASCII value
;       C=1 if it was the terminator
; Preserves: X/Y
shiftl_oswrch: .proc
                lsr a
                php
                jsr oswrch
                plp
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Handle OSBYTE $80, X<=4
;
; Entry: ?os_a = value read from joystick
;        X = X value for OSBYTE $80 call
;        
osbyte_80_generic: .proc
                cpx #0
                beq test_fire

                lda os_a
                and max_value_masks-1,x
                bne max_value

                lda os_a
                and min_value_masks-1,x
                bne min_value

zero:
                ldx #$00
                ldy #$80
                rts

max_value:
                ldx #$ff
                ldy #$ff
                rts

min_value:
                ldx #$00
                ldy #$00
                rts

test_fire:
                ldy #4          ;fake last ADC conversion channel
                
                lda os_a
                and #jfire1_mask
                bne fire_yes
fire_no:
                ldx #0
                rts

fire_yes:
                ldx #1
                rts

min_value_masks: .byte jright_mask,jup_mask,0,0
max_value_masks: .byte jleft_mask,jdown_mask,0,0
                .endproc

;-------------------------------------------------------------------------
;
; Sets jflags bits: jkeys set, jjoy clear, jindex set.
;
; Entry: A = new values for jindex, jkeys, jjoy
; Preserves: X
set_jflags: .proc
                .section set_jkeys_mode_workspace
set_bits: .fill 1
                .endsection
                sta set_bits
                ldy #State.jflags
                jsr read_state
                and #~(State.jflags.jindex_mask|State.jflags.jkeys_mask|State.jflags.jjoy_mask)
                ora set_bits
                jmp write_state
                .endproc
               
;-------------------------------------------------------------------------
;
; Print joystick action name, padded on the right with spaces.
;
; Entry: X = joystick action index, or $FF for blank
print_joystick_action_name: .proc
                .section print_joystick_action_name_workspace
pja_index: .fill 1
                .endsection

                inx
                stx pja_index
                txa
                asl a           ;*2, C=0
                asl a           ;*4, C=0
                adc pja_index   ;*5
                tay
print:
                ldx #4
-
                lda joystick_actions.names,y
                jsr oswrch
                iny
                dex
                bpl -
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Parse <no> argument from command line. Does a BRK for invalid
; joystick numbers.
;
; Entry: ($f2),y = command line pointer
; Exit: ($f2),y = updated command line pointer
;       A = joystick index, 0-3
parse_jno: .proc
                jsr strtoi
                sec
                sbc #1
                cmp #4
                bcc +
                ldx #errors_table.bad_jno_offset
                jmp do_error
+
                rts
                .endproc
;
;-------------------------------------------------------------------------
;
; Wait for a keypress. Print the pressed key's name.
;
; Exit: X = INKEY value of key pressed
verbose_get_key: .proc
                .section verbose_get_key_workspace
kindex: .fill 1

; if bit 7 set, waiting for no keys pressed. So 
waiting_for_no_keys: .fill 1
                .endsection

                sec
main_loop:
                ror waiting_for_no_keys

                lda #num_keys-1
                sta kindex
keys_loop:
                ldx kindex
                lda key_inkey_numbers_table,x
                pha             ;save INKEY number
                ora #$80        ;form true INKEY number
                tax
                lda #$81
                jsr osbyte_yff
                pla             ;restore INKEY number
                
                cpx #$ff        ;C=1 if pressed
                beq pressed     ;taken if pressed

                dec kindex
                bpl keys_loop

                ; The end of the table is only reached if no keys
                ; pressed. So arrange for waiting_for_no_keys to get
                ; reset when repeating.
                clc
                bcc main_loop

pressed:
                ; If it's escape, sort it out.
                cmp #inkey(key_escape)
                bne not_escape_pressed

                lda #$7d        ;Set Escape condition (AUG p148)
                jmp osbyte

not_escape_pressed:
                ; If still waiting for no keys, go right back to the
                ; start. The flag will remain set.
                bit waiting_for_no_keys
                bmi verbose_get_key

                cmp #$80        ;C=1 if name is string table offset
                ora #$80        ;form true INKEY number
                tax             ;X=INKEY number

                ldy kindex
                lda key_names_table,y
                bcs string_name

                ; Name is 1 char
                jmp oswrch

string_name:
                ; Name is multiple chars
                tay
string_name_loop:
                lda key_strings_table,y
                jsr shiftl_oswrch
                iny
                bcc string_name_loop
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Return value indicating whether hardware type is valid.
;
; Exit: C=1 if valid type:
;            V=0 if Electron
;            V=1 if Master
;       C=0 if invalid type
; Preserves: A/X/Y
is_valid_hw: .proc
                pha
                txa
                pha
                tya
                pha
                ; https://beebwiki.mdfs.net/OSBYTE_%2600
                lda #0
                ldx #1
                jsr osbyte
                cpx #0
                beq electron
                cpx #3
                beq master
                ; Not valid
                clc
                jmp done

electron:
                clv
                bvc done        ;i.e., JMP
master:
                bit $8003       ;set V - there's a $4c there
done:
                pla
                tay
                pla
                tax
                pla
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Check valid hardware, doing a BRK if not valid.
;
; Exit: C=1 - same as is_valid_hw
;       Will do a BRK if any other values
;
must_be_valid_hw: .proc
                jsr is_valid_hw
                bcc error
                rts
error:
                ldx #errors_table.incompatible_hw_offset
                jmp do_error
                
                .endproc

;-------------------------------------------------------------------------

                .section read_or_write_state_workspace
state_ptr: .fill 2
                .endsection
                
;-------------------------------------------------------------------------
;
; Read 1 byte from the ROM state.
;
; Entry: Y = offset into State struct
; Exit: A = value read
; Preserves: X/Y
read_state: .proc
                jsr must_be_valid_hw
                bvs master

electron:
                stx state_ptr+0
                ldx elk_state_offsets,y
                lda $200,x
                ldx state_ptr+0
                rts

master:
                .cpu '65c02'
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+1
                stz state_ptr+0
                plx
                lda (state_ptr),y
                .cpu 'default'
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Write 1 byte to the ROM state.
;
; Entry: A = value to write
;        Y = offset into State struct
; Preserves: A/X/Y
write_state: .proc
                jsr must_be_valid_hw
                bvs master

electron:
                stx state_ptr+0
                ldx elk_state_offsets,y
                sta $200,x
                ldx state_ptr+0
                rts

master:
                .cpu '65c02'
                pha
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+1
                stz state_ptr+0
                plx
                pla
                sta (state_ptr),y
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; Restore default BYTEV and KEYV vectors.
;
; Preserves: P/A/X/Y

reset_default_vectors: .proc
                .section reset_default_vectors_workspace
rdv_ptr: .fill 2
                .endsection
                
                php
                sei
                tya
                pha

                lda default_vectors_ptr+0
                sta rdv_ptr+0
                lda default_vectors_ptr+1
                sta rdv_ptr+1

                ldy #<bytev
                jsr restore_default_vector

                ldy #<keyv
                jsr restore_default_vector

                pla
                tay
                plp
                rts

restore_default_vector:
                jsr restore_default_vector_byte
restore_default_vector_byte:
                lda (rdv_ptr),y
                sta $200,y
                iny
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick: .proc
                jsr is_valid_hw
                lda #0
                bcc done
                bvc read_joystick_elk
                bvs read_joystick_master
done:
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Master.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_master: .proc
                .cpu '65c02'
                php
                sei
                lda acccon
                pha
                lda #acccon.ifj
                tsb acccon
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                plx
                stx acccon
                plp
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Electron.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_elk:
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                rts

;-------------------------------------------------------------------------
                .endsection common
;-------------------------------------------------------------------------
                .section library
;-------------------------------------------------------------------------
; 
; jmp_default_osbyte
;
jmp_default_osbyte: .proc
                php
with_p_already_pushed:
                sei
                sty os_seia         ;caution
                ldy #<bytev
                bne jmp_default_vector_routine
                .endproc
                
jmp_default_keyv: .proc
                php
with_p_already_pushed:
                sei
                sty os_seia         ;caution
                ldy #<keyv
                .cerror *!=jmp_default_vector_routine,'fallthrough broke'
                .endproc
jmp_default_vector_routine: .proc
                pha
                lda default_vectors_ptr+0
                sta os_seiwk+0
                lda default_vectors_ptr+1
                sta os_seiwk+1
                lda (os_seiwk),y ;routine LSB
                pha
                iny
                lda (os_seiwk),y ;routine MSB
                sta os_seiwk+1
                pla
                sta os_seiwk+0
                ldy os_seia
                pla

                ; If PLP re-enables interrupts, the next instruction
                ; still always executes, even if there's an interrupt
                ; pending. (PLP's IRQ check comes before the register
                ; is updated.) So this use of os_seiwk is quite safe.
                plp
                jmp (os_seiwk)
                .endproc

;-------------------------------------------------------------------------
;
; Read 8-bit integer from string.
;
; Entry: ($f2),y = pointer to string
; Exit: A = LSB of value read
;       ($f2),y = pointer to remainder of string
; Preserves: X
                .section strtoi_workspace
strtoi_value: .fill 2
                .endsection
                
strtoi:         .proc
                jsr find_string_tail
                beq bad_hex
                lda #0
                sta strtoi_value+0
                sta strtoi_value+1
                jsr gsread      ; EAUG p12
                bcs bad_hex     ; taken if eol
                cmp #'&'
                bne decimal
; hex value
                jsr gsread
                bcs bad_hex     ; taken if eol
                bcc got_digit   ; JMP, in effect

hex_loop:
                jsr gsread
                bcs done        ; taken if eol

got_digit:
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex     ; taken if input error
; strtoi_value<<=4
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value|=digit
                adc strtoi_value+0
                sta strtoi_value+0
                bcc hex_loop    ; always a JMP???

done:
                lda strtoi_value+0
                rts

;-------------------------------------------------------------------------

bad_hex:
                ldx #errors_table.bad_hex_offset
                jmp do_error

;-------------------------------------------------------------------------

decimal:
                cmp #'-'
                php             ; save negative flag - Z=1 if negative
                bne decimal_loop
                jsr gsread
                bcs bad_hex

decimal_loop:
                jsr atoi_1_digit; Convert 1 decimal digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex
                pha             ; save digit value
                lda strtoi_value+1
                pha             ; save value MSB
                lda strtoi_value
; strtoi_value=strtoi_value*2
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=strtoi_value*2+strtoi_value -> strtoi_value*5
                adc strtoi_value+0
                sta strtoi_value+0
                pla             ; restore value MSB
                adc strtoi_value+1
                sta strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=(strtoi_value*2+strtoi_value)*2 -> strtoi_value*5*2 -> strtoi_value*10
                asl strtoi_value
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; add in digit
                pla             ; restore digit value
                adc strtoi_value+0
                sta strtoi_value+0
                bcc L953D
                inc strtoi_value+1
                beq bad_hex     ; taken if overflow

L953D:
                jsr gsread
                bcc decimal_loop; taken if not eol
                plp             ; restore negative flag
                bne L9552    ; taken if positive
; strtoi_value=-strtoi_value
                sec
                lda #0
                sbc strtoi_value+0
                sta strtoi_value+0
                lda #0
                sbc strtoi_value+1
                sta strtoi_value+1

L9552:
                lda strtoi_value+0
                rts
                .endproc

;-------------------------------------------------------------------------

; Convert 1 decimal digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
atoi_1_digit:   .block
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs L955C
                cmp #$A

L955C:
                rts
                .endblock

;-------------------------------------------------------------------------

; Convert 1 hex digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
xtoi_1_digit:   .block
                cmp #'A'
                bcc L9563
                sbc #7

L9563:
                sec
                sbc #'0'
                cmp #$10
                rts
                .endblock

;-------------------------------------------------------------------------
;
;
print_hex_byte: .proc
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr nybble
                pla
                pha
                and #$0f
                jsr nybble
                pla
                rts

nybble:
                sed
                clc
                adc #$90
                adc #$40
                cld
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
;
; Call OSBYTE with X=$00 Y=$FF
;
osbyte_x00_yff:
                ldx #0
osbyte_yff:
                ldy #$ff
jmp_osbyte:
                jmp osbyte
                
;-------------------------------------------------------------------------
; 
; Try to find command in commands table
; Entry: ($f2),y = pointer to string
;        X = offset into command_table
; Exit: C=0 if command found
;       X = offset of routine address
;           (ready for call_command_table_routine)
find_command: .block
                .section find_command_workspace
fc_table_offset: .fill 1
fc_string_offset: .fill 1
                .endsection
                
                stx fc_table_offset
                clc
                jsr find_string_tail; Check if command line tail is empty.
                                   ; Entry: ($f2),y = command line tail
                                   ; Exit:  C=0 - something on command line
                                   ;        C=1 - nothing on command line
                sty fc_string_offset

L9245:
                ldy fc_string_offset
                dex
                dey

L9249:
                inx
                iny
                lda command_table,x
                sec
                beq done        ; taken if end of table reached
                bmi L9269
                eor ($F2),y
                and #$5F
                beq L9249
                lda ($F2),y
                cmp #'.'
                beq L9271

L925F:
                inx
                lda command_table,x
                bpl L925F       ; taken if end of command name reached

L9265:
                inx
                inx
                inx
                bne L9245

L9269:
                lda ($F2),y
                jsr isalpha     ; Check if char is alphabetic
                                ; Entry: A = char of interest
                                ; Exit:  C=0 if alpha, C=1 if not alpha
                bcc L9265       ; taken if alpha
                dey

L9271:
                iny
                dex

L9273:
                inx
                lda command_table,x
                bpl L9273
                clc

done:
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Convert char to upper case.
; 
toupper: .proc
                cmp #'a'
                bcc +
                cmp #'z'+1
                bcs +
                and #$df
+
                rts
                .endproc
                
;-------------------------------------------------------------------------

; Check if char is alphabetic
; Entry: A = char of interest
; Exit:  C=0 if alpha, C=1 if not alpha

isalpha:        .block
                pha             ; store char
                and #$DF        ; convert lower case to upper case
                cmp #'A'
                bcc not_alpha   ; taken if not alpha
                cmp #'Z'+1
                bcc done        ; taken if alpha

not_alpha:
                sec

done:
                pla             ; restore char
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Print 0-terminated string following call.
;
; Preserves: X
print_following_string: .proc
                .section print_following_string_workspace
pfs_ptr: .fill 2
                .endsection

loop:
                ; inc address on stack and store in pfs_ptr
                clc
                pla
                adc #1
                sta pfs_ptr+0
                tay
                pla
                adc #0
                sta pfs_ptr+1
                pha
                tya
                pha

                ; fetch next byte from string
                ldy #0
                lda (pfs_ptr),y
                beq done
                jsr oswrch
                jmp loop

done:
                rts
                
                .endproc                

;-------------------------------------------------------------------------
;
; Cause an error.
;
; Entry: X = offset of error data in errors_table
do_error: .proc
                ldy #0
                sty brkbuf
                dex
                dey

L935E:
                inx
                iny
                lda errors_table,x
                sta brkbuf+1,y
                bne L935E
                jmp brkbuf
                .endproc
                
;-------------------------------------------------------------------------
;
; Find string tail.
; Entry: ($f2),y = string pointer
; Exit: C=0 - something on command line, ($f2),y points to it, A=first char
;       C=1 - nothing on command line, ($f2),y points to end, A=13
; Preserves: X
retry_find_string_tail:
                iny
find_string_tail:
                lda ($f2),y     ; read next value from command line
                cmp #13
                beq _done       ; taken with C=1 if eol
                cmp #' '
                beq retry_find_string_tail ; taken with C=1 if space -
                                          ; move to next byte and try
                                          ; again
                clc
_done:
                rts

;-------------------------------------------------------------------------
;
; Call found command's command table routine.
; Entry: X = offset into command table of MSB of command routine
call_command_table_routine: .proc
                lda command_table,x
                pha
                lda command_table+1,x
                pha
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Switch cursor on (con) or off (coff)
; 
con:
                ldx #con_vdu-cset_vdu
                jmp cset
coff:
                ldx #coff_vdu-cset_vdu
cset:
                ldy #10
cset_loop:
                lda cset_vdu,x
                jsr oswrch
                inx
                dey
                bne cset_loop
                rts
                
cset_vdu:
con_vdu:
                .byte 23,1,1
coff_vdu:
                .byte 23,1,0
                ; doens't matter what comes next...
                
;-------------------------------------------------------------------------
                .endsection library
;-------------------------------------------------------------------------
