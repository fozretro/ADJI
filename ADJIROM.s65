                .include "submodules/beeb/include/beeb.s65"
                .edef '\\','\'

;-------------------------------------------------------------------------

default_vectors_ptr=$ffb7

os_a=$ef ; A value for osbyte/osword
os_x=$f0 ; X value for osbyte/osword
os_y=$f1 ; Y value for osbyte/osword

; seems to be relatively safe to use for brief periods with IRQs
; disabled
os_seiwk=$fa

; Routines that do PLA:<<restore ROM>>:PLA:PLP:RTS - as is part of the
; extended vector handling mechanism.
os_restore_rom_master=$ffa4
os_restore_rom_electron=$ff9c

;-------------------------------------------------------------------------
;
; See https://beebwiki.mdfs.net/OSBYTEs

; Placeholder OSBYTE used to indicate that the ROM is actually being
; entered due to KEYV.
keyv_osbyte=83
                
;-------------------------------------------------------------------------

brkbuf=$100

rom_name='ADJI'
rom_ver='0.01'

default_overlay_address=$150
                
;-------------------------------------------------------------------------

State: .struct
jflags: .fill 1
up: .fill 1
down: .fill 1
left: .fill 1
right: .fill 1
fire: .fill 1
               .endstruct

; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
master_spare=$0261
                
elk_jflags=$0290                ;
elk_up=$02a8                    ;keyboard
elk_down=$02a9                  ;keyboard
elk_left=$02aa                  ;lower-priority BASIC
elk_right=$02f5                 ;unused by Electron OS
elk_fire=$02f6                  ;unused by Electron OS

machine_type_other=0
machine_type_electron=1
machine_type_master=2

jup_mask=1
jdown_mask=2
jleft_mask=4
jright_mask=8
jfire_mask=16
                
;-------------------------------------------------------------------------

struct_section: .macro
                .struct
                .dsection \1
                .ends
                .endmacro

*=$a8
                ; Leaf routines that only use transient zp workspace
                .union
                .struct_section verbose_get_key_workspace
                .struct_section print_joystick_action_name_workspace
                .endunion

                ; Leaf routines that return a result in zero page
                .union
                .struct_section strtoi_workspace
                .endunion

                ; * commands
                .union
                .struct_section cmd_jtest_workspace
                .struct_section cmd_jon_workspace
                .endunion
                
                .cerror *>$b0,'zp overflow'

;-------------------------------------------------------------------------

*=$b0
                ; Leaf routines that only use transient zp workspace
                ; and make no FS calls (or can survive their workspace
                ; being zapped if one is made)
                .union
                .struct_section print_following_string_workspace
                .struct_section find_command_workspace
                .struct_section reset_default_vectors_workspace
                .struct_section read_or_write_state_workspace
                .endunion
                .cerror *>$c0,'FS scratch zp overflow'

;-------------------------------------------------------------------------

*=$8000
                .dsection code
                .if debug
                ; The debug ROM is for loading into sideways RAM or
                ; similar, and can occupy the full 16 KB.
                .cerror *>$c000,'code overflow'
                .else
                ; The real ADJI ROM is 4 KB.
                .cerror *>$9000,'code overflow'
                .endif
                
;-------------------------------------------------------------------------

                .section code
rom_header:
                .byte 0,0,0     ;language entry (none)
                jmp svc         ;service entry
                .byte $82       ;ROM type: service entry, 6502 code
                .byte <rom_copyright
                .byte 0
rom_title:
                .text rom_name
                .byte 0
rom_version:
                .text rom_ver
rom_copyright:
                .byte 0
                .text '(C) 2023 Retro Hardware'
rom_copyright_end:
                .byte 0

;-------------------------------------------------------------------------

command_table_entry: .function name,routine,help_offset
_start:
                .cerror (routine&$8000)==0,'routine address bit 15 must be set'
                .text name
                .byte >(routine-1)
                .byte <(routine-1)
                .byte help_offset
                .endfunction _start-command_table
                
command_table: .block
subjects_offset=*-command_table
                .command_table_entry "ADJI",help_adji,help_table.none_offset
                .byte 0
cmds_offset=*-command_table
                .command_table_entry "JON",cmd_jon,help_table.jon_offset
                .command_table_entry "JOFF",cmd_joff,help_table.none_offset
                .command_table_entry "JKEYS",cmd_jkeys,help_table.jkeys_offset
                .command_table_entry "JTEST",cmd_jtest,help_table.jtest_offset
                .command_table_entry "KTEST",cmd_ktest,help_table.none_offset
                .byte 0
                .endblock

help_table: .block
jtest_offset=*-help_table
                .text ' <no>'
none_offset=*-help_table
                .text 0
jon_offset=*-help_table
                .text ' <no> (O)',0
jkeys_offset=*-help_table
                .text ' <no> (<up> <down> <left> <right> <fire>)',0
                .endblock

;-------------------------------------------------------------------------

error_table_entry: .function err,text
_start:
                .byte err
                .text text
                .byte 0
                .endfunction _start-errors_table

errors_table: .block
bad_hex_offset: .error_table_entry $fe,'Bad hex'
incompatible_hw_offset: .error_table_entry $ff,'Electron/Master 128 only'
key_missing_offset: .error_table_entry $dc,'Key missing'
bad_jno_offset: .error_table_entry $dc,'Bad joystick'
no_free_hazel: .error_table_entry $ff,'No free FS RAM'
bad_mode: .error_table_entry $ff,'Bad mode'
todo_offset: .error_table_entry $ff,'TODO'
electron_todo_offset: .error_table_entry $ff,'Electron = TODO'
                .endblock
                
;-------------------------------------------------------------------------

key_table_entry: .macro ascii,name,key_number
                .byte \ascii
                .text \name
                .byte \key_number|$80
                .endmacro

keys_table:
                ; BBC/Electron keys
                .key_table_entry 'A','A',key_a
                .key_table_entry 'B','B',key_b
                .key_table_entry 'C','C',key_c
                .key_table_entry 'D','D',key_d
                .key_table_entry 'E','E',key_e
                .key_table_entry 'F','F',key_f
                .key_table_entry 'G','G',key_g
                .key_table_entry 'H','H',key_h
                .key_table_entry 'I','I',key_i
                .key_table_entry 'J','J',key_j
                .key_table_entry 'K','K',key_k
                .key_table_entry 'L','L',key_l
                .key_table_entry 'M','M',key_m
                .key_table_entry 'N','N',key_n
                .key_table_entry 'O','O',key_o
                .key_table_entry 'P','P',key_p
                .key_table_entry 'Q','Q',key_q
                .key_table_entry 'R','R',key_r
                .key_table_entry 'S','S',key_s
                .key_table_entry 'T','T',key_t
                .key_table_entry 'U','U',key_u
                .key_table_entry 'V','V',key_v
                .key_table_entry 'W','W',key_w
                .key_table_entry 'X','X',key_x
                .key_table_entry 'Y','Y',key_y
                .key_table_entry 'Z','Z',key_z
                .key_table_entry '0','0',key_0
                .key_table_entry '1','1',key_1
                .key_table_entry '2','2',key_2
                .key_table_entry '3','3',key_3
                .key_table_entry '4','4',key_4
                .key_table_entry '5','5',key_5
                .key_table_entry '6','6',key_6
                .key_table_entry '7','7',key_7
                .key_table_entry '8','8',key_8
                .key_table_entry '9','9',key_9
                .key_table_entry '-','-',key_minus
                .key_table_entry ';',';',key_semicolon
                .key_table_entry ':',':',key_colon
                .key_table_entry ',',',',key_comma
                .key_table_entry '.','.',key_stop
                .key_table_entry '/','/',key_slash
                .key_table_entry ' ',"SPACE",key_space
                .key_table_entry $1B,"ESCAPE",key_escape
                .key_table_entry $7F,"DELETE",key_delete
                .key_table_entry $D,"RETURN",key_return
                .key_table_entry $8B,"CURSOR UP",key_up
                .key_table_entry $8A,"CURSOR DOWN",key_down
                .key_table_entry $88,"CURSOR LEFT",key_left
                .key_table_entry $89,"CURSOR RIGHT",key_right
                .key_table_entry $87,"COPY",key_copy
                .key_table_entry 1,"SHIFT",key_shift
                .key_table_entry 2,"CTRL",key_ctrl
                .key_table_entry 3,"CAPS LOCK",key_caps_lock
                
                ; BBC keys
                .key_table_entry '@','@',key_at
                .key_table_entry '[','[',key_left_square_bracket
                .key_table_entry '\\','\\',key_backslash
                .key_table_entry ']',']',key_right_square_bracket
                .key_table_entry '^','^',key_caret
                .key_table_entry '_','_',key_underline
                .key_table_entry 9,"TAB",key_tab
                .key_table_entry 4,"SHIFT LOCK",key_shift_lock
                .key_table_entry $80,"f0",key_f0
                .key_table_entry $81,"f1",key_f1
                .key_table_entry $82,"f2",key_f2
                .key_table_entry $83,"f3",key_f3
                .key_table_entry $84,"f4",key_f4
                .key_table_entry $85,"f5",key_f5
                .key_table_entry $86,"f6",key_f6
                .key_table_entry $87,"f7",key_f7
                .key_table_entry $88,"f8",key_f8
                .key_table_entry $89,"f9",key_f9
                
                ; Master 128 keys
                .key_table_entry '0','NUM 0',$6a
                .key_table_entry '1','NUM 1',$6b
                .key_table_entry '2','NUM 2',$7c
                .key_table_entry '3','NUM 3',$6c
                .key_table_entry '4','NUM 4',$7a
                .key_table_entry '5','NUM 5',$7b
                .key_table_entry '6','NUM 6',$1a
                .key_table_entry '7','NUM 7',$1b
                .key_table_entry '8','NUM 8',$2a
                .key_table_entry '9','NUM 9',$2b
                .key_table_entry '+','NUM +',key_numpad_plus
                .key_table_entry '-','NUM -',key_numpad_minus
                .key_table_entry '/','NUM /',key_numpad_divide
                .key_table_entry '#','NUM #',key_numpad_hash
                .key_table_entry '*','NUM *',key_numpad_multiply
                .key_table_entry ',','NUM ,',key_numpad_comma
                .key_table_entry $d,'NUM RETURN',key_numpad_return
                .key_table_entry $7f,'NUM DELETE',key_numpad_delete
                .key_table_entry '.','NUM .',key_numpad_stop
                .text 0
                
;-------------------------------------------------------------------------

svc: .proc
                pha
                cmp #$15
                beq unclaimed   ;fast path for 100 Hz polling
                                ;interrupt
                cmp #4
                beq star
                cmp #9
                beq help
                ; https://beebwiki.mdfs.net/Using_high_workspace
                cmp #$22
                beq claim_hazel
                cmp #$24
                beq count_hazel
unclaimed:
                pla
done:
                ldx $f4
                rts

claimed:
                pla
                lda #0
                beq done    ;i.e., JMP

count_hazel:
                dey             ;1 page required
                jmp unclaimed

claim_hazel:
                tya
                cmp #$dc        ;run out of HAZEL space?
                bcc +           ;taken if not run out
                lda #0          ;indicate workspace unavailable
+
                sta $df0,x
                iny             ;claim 1 page
                jmp unclaimed
                
help:
                tya
                pha
                jsr find_string_tail
                bcs no_help_subject ;taken if command line empty
                ldx #command_table.subjects_offset
                pla
                pha
                tay
                jsr find_command ;try to find subject
                bcc found_subject
                ; Command line not for us - do nothing and pass on.
pla_tay_unclaimed:
                pla
                tay
                jmp unclaimed

no_help_subject:
                jsr print_help_banner
                ldx #command_table.subjects_offset
                jsr print_help
                jmp pla_tay_unclaimed

found_subject:
                jsr print_help_banner
                sec
                jsr call_command_table_routine
                jmp pla_tay_unclaimed

star:
                tya
                pha
                ldx #command_table.cmds_offset
                jsr find_command
                bcc found_command
                jmp pla_tay_unclaimed
                
found_command:
                clc
                jsr call_command_table_routine
                pla
                tay
                jmp claimed

print_help_banner .proc
                jsr osnewl
                ldy #<rom_title
-
                lda rom_header,y
                bne +
                lda #' '
+
                jsr oswrch
                iny
                cpy #rom_copyright-rom_header
                bne -
                rts
                
                .endproc
                
                .endproc

;-------------------------------------------------------------------------

help_adji: .proc
                ldx #command_table.cmds_offset
                jmp print_help
                .endproc

;-------------------------------------------------------------------------
;
; Print help for part of the commands table.
;
; Entry: X = offset of first command
;
print_help: .proc
                jsr osnewl
cmds_loop:
                lda command_table,x
                beq done
                lda #' '
                jsr oswrch
                jsr oswrch
cmd_name_loop:
                lda command_table,x
                bmi name_done
                jsr oswrch
                inx
                bne cmd_name_loop
name_done:
                inx
                inx
                ldy command_table,x
                inx
help_loop:
                lda help_table,y
                beq next
                jsr oswrch
                iny
                bne help_loop
next:
                jsr osnewl
                jmp cmds_loop
done:
                rts
                .endproc

;-------------------------------------------------------------------------

cmd_joff:
                jsr reset_default_vectors
                rts

;-------------------------------------------------------------------------
                
cmd_jon: .proc
                .section cmd_jon_workspace
joystick_index: .fill 1
use_overlay: .fill 1
xvectors: .fill 2
                .endsection

                jsr must_be_valid_hw

                jsr parse_jno
                sta joystick_index

                lda #$80
                sta use_overlay

                jsr find_string_tail
                bcs got_mode

                and #$df
                cmp #'O'
                beq got_mode
                cmp #'X'
                beq dont_use_overlay

                ldx #errors_table.bad_mode
                jmp do_error

dont_use_overlay:
                asl use_overlay
got_mode:
                bit use_overlay
                bmi install_overlay

install_xvector:
                lda #$a8        ;read extended vector table address
                ldx #$00
                ldy #$ff
                jsr osbyte
                stx xvectors+0
                sty xvectors+1

                jsr must_be_valid_hw
                bvs +           ;taken if Master 128
                ldx #errors_table.electron_todo_offset
                jmp do_error
+

                php
                sei
                lda #$ff
                sta bytev+1
                ldy #(<bytev)/2*3
                sty bytev+0
                lda #<handle_osbyte_xvector_master
                sta (xvectors),y
                iny
                lda #>handle_osbyte_xvector_master
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y
                plp
                rts

; handle_osbyte_routines:
;                 .word handle_osbyte_electron
;                 .word handle_osbyte_master
                
install_overlay:
                ldx #errors_table.todo_offset
                jmp do_error
                
                .endproc

;-------------------------------------------------------------------------
;
; Handle OSBYTE on Master 128 when called via extended vector.
;
; Entry: A/X/Y = as per OSBYTE
; 
handle_osbyte_xvector_master: .proc
                .cpu '65c02'
                cmp #$80
                bne default     ;taken if certainly not ADVAL
                cpx #5
                bcs default     ;taken if non-ADVAL OSBYTE $80
                
                sta os_a
                stx os_x
                sty os_y
                php
                sei
                ldx $f4
                lda $df0,x
                sta os_seiwk+1
                stz os_seiwk+0
                jmp handle_osbyte_master

default:
                jmp jmp_default_osbyte
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine for Master 128.
;
; Entry: A/X/Y/P as per OSBYTE or KEYV (according to entry point)
;
overlay_master: .block
                .cpu '65c02'
keyv_entry_offset=*-overlay_master
                lda #keyv_osbyte
osbyte_entry_offset=*-overlay_master
                php
                sei
                pha             ;save input A
rom_offset=*+1-overlay_master
                lda #$ff
                sta $fe30
workspace_page=*+1-overlay_master
                lda #$ff
                jmp handle_osbyte_overlay_master
                .endblock

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine suffix for Master 128
;
; Entry: A = workspace address MSB
;        X/Y = as per OSBYTE
;        Stack = [A, P, OSBYTE ret]
; 
handle_osbyte_overlay_master:
                ; Store workspace address in SEIWK.
                sta os_seiwk+1
                stz os_seiwk+0

                ; Store input registers in zero page.
                pla             ;restore input A
                sta os_a
                stx os_x
                sty os_y

                plx             ;restore input P

                ; Save ROMSEL
                lda $f4
                pha
                
                ; Make ROMSEL and $f4 consistent
                lda $fe30
                sta $f4

                ; Insert overlay exit routine addres
                lda #>handle_overlay_exit_master-1
                pha
                lda #<handle_overlay_exit_master-1
                pha

                phx             ;Save input P

                jmp handle_osbyte_master

; Entry: A/X/Y/P as per OSBYTE return
; Stack: [old ROMSEL, return address]
handle_overlay_exit_master:
                .cpu '65c02'
                pha
                php
                phx
                tsx
                ; S = X P A ROMSEL RetL RetH
                lda $104,x      ;ROMSEL
                pha             ;S = ROMSEL | X P A ROMSEL RetL RetH
                lda $102,x      ;P
                sta $104,x      ;S = ROMSEL | X P A P RetL RetH
                pla             ;S = | X P A P RetL RetH
                sta $102,x      ;S = | X ROMSEL A P RetL RetH
                plx             ;S = ROMSEL A P RetL RetH
                jmp os_restore_rom_master
                .cpu 'default'
                

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV handler for Master 128
; 
; Entry: ?os_a, ?os_x, ?os_y = OSBYTE/KEYV entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]

handle_osbyte_master:
                lda os_a

                cmp #$80
                beq osbyte_80_master
                
                ; ...?
osbyte_unhandled:
                ldx os_x
                ldy os_y
                plp
                jmp jmp_default_osbyte

osbyte_80_master:
                ; Bail if not ADVAL.
                ldx os_x
                cpx #5
                bcs osbyte_unhandled
                
                .cpu '65c02'
                ; Save old ACCCON. Page in HAZEL. Direct FRED to
                ; cartridge.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Fetch joystick index.
                ldy #State.jflags
                lda (os_seiwk),y
                and #3

                ; ?os_a = joystick value
                tay
                lda joystick_fred_offsets,y
                tay
                lda $fc00,y
                sta os_a

                ; Restore old ACCCON.
                pla
                sta acccon

                ; OK to possibly re-enable IRQs now.
                plp
                
                jmp osbyte_80_generic
                .cpu 'default'
                
;-------------------------------------------------------------------------
;
; Handle OSBYTE $80, X=0, Y<=4
;
; Entry: ?os_a = value read from joystick
;        
osbyte_80_generic: .proc
                cpx #0
                beq test_fire

                lda os_a
                and max_value_masks-1,x
                bne max_value

                lda os_a
                and min_value_masks-1,x
                bne min_value

zero:
                ldx #$00
                ldy #$80
                rts

max_value:
                ldx #$ff
                ldy #$ff
                rts

min_value:
                ldx #$00
                ldy #$00
                rts

test_fire:
                ldy #4          ;fake last ADC conversion channel
                
                lda os_a
                and #jfire_mask
                bne fire_yes
fire_no:
                ldx #0
                rts

fire_yes:
                ldx #1
                rts

min_value_masks: .byte jright_mask,jup_mask,0,0
max_value_masks: .byte jleft_mask,jdown_mask,0,0
                .endproc

;-------------------------------------------------------------------------
; 
; jmp_default_osbyte
;
jmp_default_osbyte:
                php
                sei
                pha
                sty os_y
                ldy #<bytev
                bne jmp_default_vector_routine

jmp_default_vector_routine:
                lda default_vectors_ptr+0
                sta os_a
                lda default_vectors_ptr+1
                sta os_x
                lda (os_a),y    ;get LSB of routine
                pha
                iny
                lda (os_a),y    ;get MSB of routine
                sta os_x        ;store MSB of routine
                pla             ;restore LSB of routine
                sta os_a        ;store LSB of routine
                ldy os_y        ;restore input Y
                pla             ;restore input A
                plp             ;restore input P
                jmp (os_a)      ;call routine
                
;-------------------------------------------------------------------------

cmd_jkeys:
                ldx #errors_table.todo_offset
                jmp do_error

;-------------------------------------------------------------------------

cmd_jtest: .proc
                .section cmd_jtest_workspace
joystick_index: .fill 1
action_index: .fill 1
                .endsection
                
                jsr parse_jno
                sta joystick_index
                
                jsr print_following_string
                .text 22,135
                .text 31,8,5
                .text "J O Y S T I C K   T E S T"
                .byte 0

                jsr coff

loop:
                bit $ff
                bmi done        ;taken if Escape pressed

                lda #4
                sta action_index
check_actions:
                jsr print_following_string
                .byte 31,17,0
                
                lda action_index
                clc
                adc #10         
                jsr oswrch      ;PRINT TAB(17,Y)

                ldx joystick_index
                jsr read_joystick
                
                ldx action_index
                and joystick_actions.masks,x
                bne +
                ldx #$ff        ;no action
+
                jsr print_joystick_action_name

                dec action_index
                bpl check_actions
                jmp loop

done:
                jsr con
                lda #$7e
                jsr osbyte
                lda #12
                jmp oswrch
                
                .endproc

;-------------------------------------------------------------------------
;
; Print joystick action name, padded on the right with spaces.
;
; Entry: X = joystick action index, or $FF for no blanks
print_joystick_action_name: .proc
                .section print_joystick_action_name_workspace
pja_index: .fill 1
                .endsection

                inx
                stx pja_index
                txa
                asl a           ;*2, C=0
                asl a           ;*4, C=0
                adc pja_index   ;*5
                tay
print:
                ldx #4
-
                lda joystick_actions.names,y
                jsr oswrch
                iny
                dex
                bpl -
                rts
                .endproc

;-------------------------------------------------------------------------

joystick_actions: .block
masks:
                .byte 1,2,4,8,16
names:
                ;      01234
                .text "     "
                .text "UP   "
                .text "DOWN "
                .text "LEFT "
                .text "RIGHT"
                .text "FIRE "
                .endblock

;-------------------------------------------------------------------------

cmd_ktest: .proc
                jsr print_following_string
                .text 'Press keys...',10,13,0

ktest_loop:
                jsr verbose_get_key

                jsr print_following_string
                .text ' | ',0

                bit $ff
                bpl ktest_loop

                lda #15
                ldx #0
                jsr osbyte
                rts
                
                .endproc

;-------------------------------------------------------------------------
;
; Switch cursor on (con) or off (coff)
; 
con:
                ldx #con_vdu-cset_vdu
                jmp cset
coff:
                ldx #coff_vdu-cset_vdu
cset:
                ldy #10
cset_loop:
                lda cset_vdu,x
                jsr oswrch
                inx
                dey
                bne cset_loop
                rts
                
cset_vdu:
con_vdu:
                .byte 23,1,1
coff_vdu:
                .byte 23,1,0
                ; doens't matter what comes next...
                
;-------------------------------------------------------------------------
;
; Parse <no> argument from command line. Does a BRK for invalid
; joystick numbers.
;
; Entry: ($f2),y = command line pointer
; Exit: ($f2),y = updated command line pointer
;       A = joystick index, 0-3
parse_jno: .proc
                jsr strtoi
                sec
                sbc #1
                cmp #4
                bcc +
                ldx #errors_table.bad_jno_offset
                jmp do_error
+
                rts
                .endproc
;
;-------------------------------------------------------------------------
;
; Wait for a keypress. Print the pressed key's name.
;
; Exit: X = INKEY value of key pressed
verbose_get_key: .proc
                .section verbose_get_key_workspace
vgk_ptr: .fill 2
                .endsection
                
                lda #<keys_table
                sta vgk_ptr+0
                lda #>keys_table
                sta vgk_ptr+1

keys_loop:
                ldy #0
                lda (vgk_ptr),y ;check for terminator
                beq verbose_get_key
                iny             ;skip ASCII
find_name_end_loop:
                lda (vgk_ptr),y
                beq verbose_get_key
                bmi found_name_end
                iny
                bne find_name_end_loop
found_name_end:
                tya
                pha             ;save offset of key number

                jsr poll_key

                pla             ;restore offset of key number
                bcs pressed     ;taken if key was pressed
                
                sec             ;+1 to get to next key's struct
                adc vgk_ptr+0
                sta vgk_ptr+0
                bcc keys_loop
                inc vgk_ptr+1
+
                jmp keys_loop

pressed:
wait_for_release_loop:
                pha             ;save offset
                jsr poll_key
                tax             ;X = INKEY value
                pla             ;restore offset
                bcs wait_for_release_loop

                ldy #1
print_name_loop:
                lda (vgk_ptr),y
                bmi printed_name
                jsr oswrch
                iny
                bne print_name_loop
printed_name:
                rts

; poll for key
;
; Entry: (vgk_ptr) = entry in table
;        A = offset from vgk_ptr of (INKEY value)^0x7f
; Exit: A = INKEY value
;       C=1 if key down, C=0 if key up
poll_key:
                tay
                lda (vgk_ptr),y
                eor #$7f
                pha
                tax
                ldy #$ff
                lda #$81
                jsr osbyte
                cpx #$ff
                pla
                rts
                
                .endproc
                
;-------------------------------------------------------------------------
;
; Cause an error.
;
; Entry: X = offset of error data in errors_table
do_error: .proc
                ldy #0
                sty brkbuf
                dex
                dey

L935E:
                inx
                iny
                lda errors_table,x
                sta brkbuf+1,y
                bne L935E
                jmp brkbuf
                .endproc
                
;-------------------------------------------------------------------------
;
; Find string tail.
; Entry: ($f2),y = string pointer
; Exit: C=0 - something on command line, ($f2),y points to it, A=first char
;       C=1 - nothing on command line, ($f2),y points to end, A=13
; Preserves: X
retry_find_string_tail:
                iny
find_string_tail:
                lda ($f2),y     ; read next value from command line
                cmp #13
                beq _done       ; taken with C=1 if eol
                cmp #' '
                beq retry_find_string_tail ; taken with C=1 if space -
                                          ; move to next byte and try
                                          ; again
                clc
_done:
                rts

;-------------------------------------------------------------------------
;
; Call found command's command table routine.
; Entry: X = offset into command table of MSB of command routine
call_command_table_routine: .proc
                lda command_table,x
                pha
                lda command_table+1,x
                pha
                rts
                .endproc

;-------------------------------------------------------------------------
; 
; Try to find command in commands table
; Entry: ($f2),y = pointer to string
;        X = offset into command_table
; Exit: C=0 if command found
;       X = offset of routine address
;           (ready for call_command_table_routine)
find_command: .block
                .section find_command_workspace
fc_table_offset: .fill 1
fc_string_offset: .fill 1
                .endsection
                
                stx fc_table_offset
                clc
                jsr find_string_tail; Check if command line tail is empty.
                                   ; Entry: ($f2),y = command line tail
                                   ; Exit:  C=0 - something on command line
                                   ;        C=1 - nothing on command line
                sty fc_string_offset

L9245:
                ldy fc_string_offset
                dex
                dey

L9249:
                inx
                iny
                lda command_table,x
                sec
                beq done        ; taken if end of table reached
                bmi L9269
                eor ($F2),y
                and #$5F
                beq L9249
                lda ($F2),y
                cmp #'.'
                beq L9271

L925F:
                inx
                lda command_table,x
                bpl L925F       ; taken if end of command name reached

L9265:
                inx
                inx
                inx
                bne L9245

L9269:
                lda ($F2),y
                jsr isalpha     ; Check if char is alphabetic
                                ; Entry: A = char of interest
                                ; Exit:  C=0 if alpha, C=1 if not alpha
                bcc L9265       ; taken if alpha
                dey

L9271:
                iny
                dex

L9273:
                inx
                lda command_table,x
                bpl L9273
                clc

done:
                rts
                .endblock

;-------------------------------------------------------------------------

; Check if char is alphabetic
; Entry: A = char of interest
; Exit:  C=0 if alpha, C=1 if not alpha

isalpha:        .block
                pha             ; store char
                and #$DF        ; convert lower case to upper case
                cmp #'A'
                bcc not_alpha   ; taken if not alpha
                cmp #'Z'+1
                bcc done        ; taken if alpha

not_alpha:
                sec

done:
                pla             ; restore char
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Print 0-terminated string following call.
;
; Preserves: X
print_following_string: .proc
                .section print_following_string_workspace
pfs_ptr: .fill 2
                .endsection

loop:
                ; inc address on stack and store in pfs_ptr
                clc
                pla
                adc #1
                sta pfs_ptr+0
                tay
                pla
                adc #0
                sta pfs_ptr+1
                pha
                tya
                pha

                ; fetch next byte from string
                ldy #0
                lda (pfs_ptr),y
                beq done
                jsr oswrch
                jmp loop

done:
                rts
                
                .endproc                

;-------------------------------------------------------------------------
;
; Return value indicating whether hardware type is valid.
;
; Exit: C=1 if valid type:
;            V=0 if Electron
;            V=1 if Master
;       C=0 if invalid type
; Preserves: A/X/Y
;-------------------------------------------------------------------------

is_valid_hw: .proc
                pha
                txa
                pha
                tya
                pha
                ; https://beebwiki.mdfs.net/OSBYTE_%2600
                lda #0
                ldx #1
                jsr osbyte
                cpx #0
                beq electron
                cpx #3
                beq master
                ; Not valid
                clc
                jmp done

electron:
                clv
                bvc done        ;i.e., JMP
master:
                bit $8003       ;set V - there's a $4c there
done:
                pla
                tay
                pla
                tax
                pla
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Check valid hardware, doing a BRK if not valid.
;
; Exit: C=1 - same as is_valid_hw
;       Will do a BRK if any other values
;
must_be_valid_hw: .proc
                jsr is_valid_hw
                bcc error
                rts
error:
                ldx #errors_table.incompatible_hw_offset
                jmp do_error
                
                .endproc

;-------------------------------------------------------------------------

                .section read_or_write_state_workspace
state_ptr: .fill 2
                .endsection
                
;-------------------------------------------------------------------------
;
; Read 1 byte from the ROM state.
;
; Entry: Y = offset
; Exit: A = value read
; Preserves: X/Y
read_state: .proc
                jsr must_be_valid_hw
                bvs master

read_state_electron:
                stx state_ptr+0
                ldx elk_state_offsets,y
                lda $200,x
                ldx state_ptr+0
                rts

read_state_master:
                .cpu '65c02'
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+1
                stz state_ptr+0
                plx
                lda (state_ptr),y
                .cpu 'default'
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Write 1 byte to the ROM state.
;
; Entry: A = value to write
;        Y = offset
; Preserves: A/X/Y
write_state: .proc
                jsr must_be_valid_hw
                bvs master

                stx state_ptr+0
                ldx elk_state_offsets,y
                sta $200,x
                ldx state_ptr+0
                rts

master:
                .cpu '65c02'
                pha
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+1
                stz state_ptr+0
                plx
                pla
                sta (state_ptr),y
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------

elk_state_offsets: .proc
                .byte <elk_jflags
                .byte <elk_up
                .byte <elk_down
                .byte <elk_left
                .byte <elk_right
                .byte <elk_fire
                .endproc
                
;-------------------------------------------------------------------------
;
; Read 8-bit integer from string.
;
; Entry: ($f2),y = pointer to string
; Exit: A = LSB of value read
;       ($f2),y = pointer to remainder of string
; Preserves: X
strtoi:         .proc
                .section strtoi_workspace
strtoi_value: .fill 2
                .endsection
                
                jsr find_string_tail
                beq bad_hex
                lda #0
                sta strtoi_value+0
                sta strtoi_value+1
                jsr gsread      ; EAUG p12
                bcs bad_hex     ; taken if eol
                cmp #'&'
                bne decimal
; hex value
                jsr gsread
                bcs bad_hex     ; taken if eol
                bcc got_digit   ; JMP, in effect

hex_loop:
                jsr gsread
                bcs done        ; taken if eol

got_digit:
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex     ; taken if input error
; strtoi_value<<=4
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value|=digit
                adc strtoi_value+0
                sta strtoi_value+0
                bcc hex_loop    ; always a JMP???

done:
                lda strtoi_value+0
                rts

;-------------------------------------------------------------------------

bad_hex:
                ldx #errors_table.bad_hex_offset
                jmp do_error

;-------------------------------------------------------------------------

decimal:
                cmp #'-'
                php             ; save negative flag - Z=1 if negative
                bne decimal_loop
                jsr gsread
                bcs bad_hex

decimal_loop:
                jsr atoi_1_digit; Convert 1 decimal digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex
                pha             ; save digit value
                lda strtoi_value+1
                pha             ; save value MSB
                lda strtoi_value
; strtoi_value=strtoi_value*2
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=strtoi_value*2+strtoi_value -> strtoi_value*5
                adc strtoi_value+0
                sta strtoi_value+0
                pla             ; restore value MSB
                adc strtoi_value+1
                sta strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=(strtoi_value*2+strtoi_value)*2 -> strtoi_value*5*2 -> strtoi_value*10
                asl strtoi_value
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; add in digit
                pla             ; restore digit value
                adc strtoi_value+0
                sta strtoi_value+0
                bcc L953D
                inc strtoi_value+1
                beq bad_hex     ; taken if overflow

L953D:
                jsr gsread
                bcc decimal_loop; taken if not eol
                plp             ; restore negative flag
                bne L9552    ; taken if positive
; strtoi_value=-strtoi_value
                sec
                lda #0
                sbc strtoi_value+0
                sta strtoi_value+0
                lda #0
                sbc strtoi_value+1
                sta strtoi_value+1

L9552:
                lda strtoi_value+0
                rts
                .endproc

;-------------------------------------------------------------------------

; Convert 1 decimal digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
atoi_1_digit:   .block
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs L955C
                cmp #$A

L955C:
                rts
                .endblock

;-------------------------------------------------------------------------

; Convert 1 hex digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
xtoi_1_digit:   .block
                cmp #'A'
                bcc L9563
                sbc #7

L9563:
                sec
                sbc #'0'
                cmp #$10
                rts
                .endblock

;-------------------------------------------------------------------------
;
; Restore default BYTEV and KEYV vectors.
;
; Preserves: P/A/X/Y

reset_default_vectors: .proc
                .section reset_default_vectors_workspace
rdv_ptr: .fill 2
                .endsection
                
                php
                sei
                tya
                pha

                lda default_vectors_ptr+0
                sta rdv_ptr+0
                lda default_vectors_ptr+1
                sta rdv_ptr+1

                ldy #<bytev
                jsr restore_default_vector

                ldy #<keyv
                jsr restore_default_vector

                pla
                tay
                plp
                rts

restore_default_vector:
                jsr restore_default_vector_byte
restore_default_vector_byte:
                lda (rdv_ptr),y
                sta $200,y
                iny
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick: .proc
                jsr is_valid_hw
                lda #0
                bcc done
                bvc read_joystick_elk
                bvs read_joystick_master
done:
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Master.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_master: .proc
                .cpu '65c02'
                php
                sei
                lda acccon
                pha
                lda #acccon.ifj
                tsb acccon
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                plx
                stx acccon
                plp
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Electron.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_elk:
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                rts

joystick_fred_offsets:
                .byte $c0,$d0,$e0,$f0
                
;-------------------------------------------------------------------------

                .endsection code

;-------------------------------------------------------------------------
